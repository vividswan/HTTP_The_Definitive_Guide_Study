# 15장 - 엔터티와 인코딩

- HTTP는 매일 수십억 개의 미디어 객체를 실어 나르는 HTTP가 보장하는 것들
  - 객체가 올바르게 식별
  - 객체는 올바르게 압축이 풀림
  - 객체는 항상 최신
  - 사용자의 요구를 만족할 것
  - 네트워크 사이를 빠르고 효율적으로 이동
  - 조작되지 않고 온전하게 도착
- 이를 위해 HTTP는 엔터티를 사용

## 15.1 메시지는 컨테이너, 엔터티는 화물

- HTTP 엔터티는 메시지의 실질적인 화물
  - 엔터티 = 엔터티 헤더 + 엔터티 본문 (빈 줄(CRLF)로 나누어짐)
- HTTP/1.1의 10가지 주요 엔터티 헤더 필드
  - Content-Type : 객체의 종류
  - Content-Length : 메시지의 길이나 크기
  - Content-Language : 객체와 가장 잘 대응되는 자연어
  - Content-Encoding : 객체 데이터에 대해 행해진 변형
  - Content-Location : 객체의 또 다른 위치 (요청 시점 기준)
  - Content-Range : 부분 엔터티일 시 전체에서 어느 부분에 해당하는지 정의
  - Content-MD5 : 엔터티 본문의 콘텐츠에 대한 체크섬
  - Last-Modified : 서버에서 이 콘텐츠가 생성 혹은 수정된 날
  - Expires : 엔터티가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜, 시각
  - Allow : 리소스에 대해 허용되는 메서드
  - ETag : 이 인스터스에 대한 고유한 검사기
  - Cache-Control : 어떻게 이 문서가 캐시 될 수 있는지에 대한 지시자
- Etag, Cache-Control은 엔터티 헤더로 정의 X

### 15.1.1 엔터티 본문

- 가공되지 않은 데이터만을 담고 있음
  - 엔터티 헤더가 데이터의 의미에 대해 설명
- 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작

## 15.2 Content-Length: 엔터티의 길이

- 메시지의 엔터티 본문의 크기를 바이트 단위로 나타냄
  - 어떻게 인코딩 되었든 크기 표한 가능
- 청크 인코딩으로 전송하지 않는 이상 본문이 있을 땐 필수적
- Content-Length로 메시지가 잘렸는지 확인, 지속 커넥션을 공유하는 메시지를 올바르게 분할

### 15.2.1 잘림 검출

- 메시지가 닫혔을 때 정산적으로 닫힌 것인지, 서버에 충돌이 발생했는지 구분을 못 함
  - 잘림 검출을 위해 Content-Length 헤더가 필요
- 메시지 잘림은 캐싱 프락시 서버에서 취약
  - 잘린 메시지를 계속 제공
  - 명시적으로 Content-Length 헤더가 있어야 본문 캐시

### 15.2.2 잘못된 Content-Length

- 잘못된 값이 더 큰 피해 유발

### 15.2.3 Content-Length와 지속 커넥션(Persistent Connection)

- 지속 커넥션에선 커넥션이 닫힌 위치를 근러로 메시지의 끝을 인식하는 것이 불가능
  - Content-Length 헤더로 어디까지가 엔터티 본문이고 어디부터가 다음 메시지인지 파악
- 청크 인코딩을 할 때도 Content-Length 헤더가 필수
  - 청크 인코딩은 데이터를 각각이 특정한 크기를 갖는 일련의 청크로 쪼개어 보냄
  - 서버가 엔터티 전체의 크기를 알 수 없더라도 청크 인코딩을 통해 엔터티를 잘 정의된 크기의 조각들로 전송해야 함

### 15.2.4 콘텐츠 인코딩

- HTTP는 보안과 압축을 위해 엔터티 본문을 인코딩할 수 있게 해줌
  - 이때 Content-Length는 원본이 아닌 인코딩된 본문의 길이를 바이트 단위로 정의
- HTTP/1.1 명세에 서술된 어떤 헤더도 인코딩 되지 않은 원 본문의 길이를 보내기 위해 사용될 수 없음

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙

- 본문을 갖는 것이 허용되지 않는 메시지는 Content-Length 헤더가 무시
  - 이 경우 Content-Length는 부가 정보, 실제 길이 서술 X
  - Content-Length가 있다고 언제나 본문이 있는 것이 X
  - 가장 중요한 예는 HEAD 응답(GET에서 본문 제외하고 헤더만) -> Content-Length를 돌려줌
- 메시지가 Transfer-Encoding 헤더를 포함하고 있다면 엔터티는 '0바이트 청크'라 불리는 특별한 패턴으로 끝나야 함
  - 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상
- 메시지 유형이 엔터티 본문 허용 & Content-Length 헤더를 가짐 & Transfer-Encoding 헤더가 존재하지 않는 이상 Content-Length 값은 본문의 길이를 담음
  - Transfer-Encoding 헤더 필드를 갖고 있다면 반드시 Content-Length 헤더를 무시 (전송 인코딩은 본문을 표현하고 전송하는 방식을 바꿀 것이기 때문)
- 메시지가 'multipart/byteranges' 미디어 타입을 사용하고 길이가 별도로 정의되지 않았다면 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 결정
  - 멀티파트 유형은 자신의 크기를 스스로 결정할 수 있는 유일한 엔터티 본문 유형
- 위의 어떤 규칙에도 해당 안 될 시 엔터티는 커넥션이 닫힐 때 끝남
  - 서버만이 커넥션을 닫아서 메시지가 끝났음을 알릴 수 있음
  - 클라이언트가 닫아버리면 서버가 응답을 돌려줄 방법이 없음
- 호환을 위해 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더도 갖고 있어야 함

## 15.3 엔터티 요약

- HTTP는 불완전한 트랜스 코딩 프락시, 버그 많은 중개자 프락시 등 때문에 일부분이 전송 중에 변형이 일어남
  - 최초 엔터티 생성 시 송신자가 데이터의 체크섬을 생성하고 수신자는 체크섬으로 기본적 검사를 할 수 있음
- Content-MD5 헤더는 서버가 엔터티 본문에 MD5 알고리즘을 적용한 결과를 보냄
  - 오직 응답을 처음 만든 서버만이 계산
  - 종단 간 무결성을 검증하는 목적
  - 콘텐츠 인코딩의 적용은 끝났지만 전송 인코딩은 아직 적용하지 않은 엔터티 본문에 대한 MD5를 담고 있음
  - 그다지 자주 전송되지 않음
- IETF 초안으로 다른 요약 알고리즘들이 제안됨
  - 새로운 헤더인 Want-Digest에 품질 값을 이용해 여러 요약 알고리즘을 제안하고 선호도를 지정 가능

## 15.4 미디어 타입과 차셋(Charset)

- Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술
  - MIME 타입은 전달되는 데이터 매체의 기저 형식의 표준화된 이름
  - "주 미디어 타입/부 타입"으로 구성
- 엔터티 본문의 미디어 타입을 명시한다는 것은 중요

### 15.4.1 텍스트 매체를 위한 문자 인코딩

- 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지정
  - ex) 엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 'charset' 매개변수

### 15.4.2 멀티파트 미디어 타입

- MIME "멀티파트" 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함, 하나의 복합 메시지로 보내짐
  - 각 구성요소는 자족적으로 자신에 대해 서술하는 헤더를 포함
  - 여러 구성 요소들이 문자열 하나로 서로의 경계가 식별되게 이어져 있음
- HTTP는 멀티파트 본문도 지원
  - 폼을 채워서 제출할 때
  - 문서와 일부분을 실어 나르는 범위 응답을 할 때

### 15.4.3 멀티파트 폼 제출

- HTTP 폼 제출 시 가변 길이 텍스트 필드와 객체는 각각 멀티파트 본문을 구성하는 하나의 파트가 되어 보내짐
  - 본문은 여러 다른 종류와 길이의 값으로 채워진 폼을 허용
  - Content-Type: multipart/form-data나 Content-Type: multipart/mixed 헤더에 멀티파트 본문을 함께 보냄
  - boundary로 본문의 서로 다른 부분의 구분자로 사용

### 15.4.4 멀티파트 범위 응답

- 범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수 있음
- Content-Type: multipary/byteranges 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 옴

## 15.5 콘텐츠 인코딩

- 전송 시간을 줄이거나 암호화를 위해 HTTP 애플리케이션은 때때로 콘텐츠를 인코딩
- 발송하는 쪽에서 콘텐츠에 적용
- 엔터티 본문에 담아 수신자에게 보냄

### 15.5.1 콘텐츠 인코딩 과정

- 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성
- 원 서버이거나 다운 스트림 프락시일 인코딩 서버가 인코딩된 메시지를 생성
  - Content-Type은 같으나 Content-Length가 다름 (압축되어 있다면)
  - Content-Encoding 헤더를 인코딩된 메시지에 추가 (수신측이 디코딩 할 수 있게)
  - 수신 측 프로그램이 디코딩 하여 원본 획득
- gzip 콘텐츠 인코딩의 경우 gzip 인코딩 플레그가 붙음
  - Content-Encoding: gzip
- Content-Type은 여전히 존재해야 함
  - 엔터티의 원래 포맷 기술
  - 디코딩 된 엔터티를 보여주기 위해 필요한 정보

### 15.5.2 콘텐츠 인코딩 유형

- 표준 콘텐츠 인코딩 유형 정의
  - 확장 인코딩으로 인코딩 추가도 허용
- 인코딩은 고유한 토큰을 할당하는 IANA를 통해 표준화
- 흔히 쓰이는 콘텐츠 인코딩 (무손실 압축 알고리즘)
  - gzip (GNU zip, 효율적이고 가장 널리 쓰임)
  - compress (유닉스 파일 압축 프로그램인 'compress')
  - deflate (zlib 포맷으로 압축)
  - identity (어떠한 인코딩도 수행되지 않았음)
- 네트워크 대역폭 절약 & 전송이 완료되기를 기다리는 시간 감소
  - 대신 클라이언트가 받은 자료의 압축을 푸는 시간 발생

### 15.5.3 Accept-Encoding 헤더

- 클라이언트는 자신이 지원하는 인코딩을 목록을 Accept-Encoding 헤더로 전달
  - 없을 시 `Accept-Encoding: *`과 동일하게 간주
  - 쉼표로 목록을 구분
- 각 인코딩에 Q(quality) 값으로 선호도 표현 가능
- 토큰 `*`은 `그 외 모두`를 의미
- identity 인코딩 토큰은 오직 Accept-Encoding 헤더에만 존재할 수 있음

## 15.6 전송 인코딩과 청크 인코딩

- 전송 인코딩은 엔터티 본문에 적용되는 가역적 변환
  - 컨텐츠의 포맷과는 독립적
  - 단지 메시지의 엔터티 부분만 인코딩하는 것이 아닌 전체 메시지에 대해 적용 -> 메시지 자체의 구조 변경
  - 기본 헤더는 인코딩 X

### 15.6.1 안전한 전송

- 전송 인코딩은 안전한 전송을 위해 존재
- HTTP에서 전송된 메시지의 본문이 문제를 일으키는 이유
  - 알 수 없는 크기 -> 사이즈를 알기 전에 데이터의 전송을 시작하려는 경우 (특별한 종결 꼬리말 포함)
  - 보안 -> 이미 SSL과 같은 유명한 전송 계층 보안 방식이 있으므로 거의 사용 X

### 15.6.2 Transfer-Encoding 헤더

- 전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 단 두 개
- Transfer-Encoding
  - 어떤 인코딩이 메시지에 적용되었는지 수신자에게 전달
- TE
  - 요청 헤더에서 어떤 확장된 전송 인코딩을 사용할 수 있는지 알려줌
  - Q 값을 가질 수 있음
- 모든 전송 인코딩 값은 대소문자가 구별
- 최신 HTTP 명세는 청크 인코딩만을 정의

### 15.6.3 청크 인코딩

- 메시지를 일정 크기의 청크 여럿으로 쪼갬
- 서버는 각 청크를 순차적으로 보냄
- 메시지를 보내기 전 전체 크기를 알 필요가 없어짐
  - 본문이 동적으로 생성 후 그중 일부를 버퍼에 담음
  - 본문 전체를 모두 보낼 때까지 청크를 크기와 함께 보내는 것을 반복
- 청크와 지속 커넥션
  - 지속 커넥션에서는 본문을 쓰기 전 반드시 Content-Length 헤더에 본문의 길이를 담아야 함
  - 동적인 경우 본문의 길이를 알아내는 것이 불가능
  - 청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 함으로써 딜레마에 대한 해법 제공
  - 서버의 일부를 버퍼에 담고 한 덩어리씩 모두 보낼 때까지 반복
  - 크기가 0인 청크로 본문이 끝났음을 알리기 전까지 커넥션을 열린 채로 유지
- 청크의 스트림 : 16진수 형식의 길이 값 + CRLF + 청크 데이터
- 클라이언트 또한 청크 인코딩된 데이터를 서버로 전송
- 청크 인코딩된 메시지의 트레일러
  - 클라이언트의 TE 헤더가 트레일러를 받아들일 수 있음을 나타낼 경우 트레일러 추가 가능
  - 서버에 의해 트레일러가 추가되었고 클라이언트가 이해할 필요가 없는 메타데이터 일 때 클라이언트가 무시하고 버려도 되는 경우 트레일러 추가 가능
  - 트레일러엔 메시지 시작 시점에서 값을 알 수 없는 추가적인 헤더 필드를 담을 수 있음(Content-MD5 같은)
  - 메시지 헤더는 Trailer 헤더를 포함
  - Transfer-Encoding, Trailer, Content-Length를 제외한 모든 HTTP 헤더가 트레일러로 보낼 수 있음

### 15.6.4 콘텐츠와 전송 인코딩의 조합

- 콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있음
- 콘텐츠 인코딩으로 파일 압축 후 청크 데이터를 전송 인코딩을 사용해서 전송
- 본문을 재구축 하는 절차는 이와 순서가 반대

### 15.6.5 전송 인코딩 규칙

- 전송 인코딩의 집합은 반드시 `chunked`를 포함
- 청크 전송 인코딩 사용 시 메시지 본문에 적용된 마지막 전송 인코딩 존재해야 함
- 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용
- 어떠한 HTTP/1.1 애플리케이션이라도 최소한 정크 인코딩만은 반드시 지원
- 비 HTTP/1.1 애플리케이션에 전송 인코딩된 메시지를 보내지 않도록 주의
  - 서버가 전송 인코딩을 이해 못 할 시 501 Unimplemented 상태 코드로 응답해야 함

## 15.7 시간에 따라 바뀌는 인스턴스

- 웹 객체는 정적이지 않음
  - 같은 URL로 시간에 따라 다른 버전의 객체를 가리킬 수 있음
- 홈페이지를 하나의 객체, 각각 다른 버전을 객체의 각각 다른 인스턴스라 가정
  - 시간의 흐름에 따라 리소스의 다른 인스턴스를 받을 수 있음
- 인스턴스 조작
  - HTTP 프로토콜이 어떤 특정한 종류의 요청이나 응답을 다루는 방법들을 정의
  - 객체의 인스턴스에 적용
  - 대표적으로 범위 요청과 델타 인코딩 (클라이언트가 본인이 갖고 있는 리소스 사본이 서버와 같은지 확인 후 다르면 요청할 수 있는 능력)

## 15.8 검사기와 신선도

- 조건부 요청
  - 문서가 클라이언트에서 만료 시 클라이언트는 반드시 서버에게 최신 사본을 요구
  - 문서 변경이 없을 시 그냥 갖고 있던 캐시 된 사본 사용
  - 신선도, 검사기, 조건 세 가지가 주요 개념

### 15.8.1 신선도

- 서버는 Expires나 Cache-Control 헤더를 통해 신선한가에 대한 정보 제공
- Expire은 만료되는 정확한 날짜 명시
  - 그들의 시계를 반드시 동기화시켜야 함
  - 네트워크 시간 프로토콜 (Network Time Protocol, NTP)와 같은 시계 동기화 프로토콜로 동기화
  - 상대시간을 이용해 만료를 정의하는 메커니즘이 더 쓸만함
- Cache-Control 헤더는 문서의 최대 수명을 문서가 서버를 떠난 후로부터의 총 시간을 초 단위로 정함
  - 동기화에 의존하지 않으므로 더 정확한 결과
  - 수명, 유효기간뿐 아니라 선도를 서술하기 위해 사용되며 강력함

### 15.8.2 조건부 요청과 검사기

- 대개 서버에 있는 문서는 여전히 캐시에 들어있는 신선하지 못한 사본과 같음
  - 이때 그 문서를 다시 가져온다면 네트워크 대역폭 낭비, 불필요한 부하
- 조건부 요청으로 리소스가 바뀐 경우에만 사본 요청 가능
  - 조건부 요청은 'If-'로 시작
  - 조건이 참이 아닐 시 서버는 HTTP 에러 코드를 돌려보냄
- ex) If-Modified-Since: Sat, 92 Jun 2002, 14:30:00 GMT
  - 2002년 6월 29일 이후에 변경된 경우에만 한해서 파일을 보내달라고 요청
- If-None-Match 조건부 헤더는 문서의 ETag 값을 평가
  - Etag는 특별한 키워드 or 엔터티와 관련된 버전 식별 태그
- HTTP는 검사기를 약한 검사기와 강한 검사기 두 가지로 분류
  - 약한 검사기는 리소스의 인스턴트를 고유하게 식별하지 못하는 경우도 있음 (객체의 바이트 단위 크기, 최종 변경 시각 ...)
  - 강한 검사기는 언제나 고유하게 식별 (리소스 콘텐츠에 대한 암호 체크섬, ETag 헤더 ...)
- ETag 헤더는 유연 (어떠 텍스트 값, 버전 번호, 요약 체크섬 등등)
- 캐시의 재검사를 피하고 겉모양새만 약간 고치고 싶을 땐 태그 앞에 'W/'를 붙여 약한 엔터티 태그임을 알릴 수 있음

## 15.9 범위 요청

- HTTP는 클라이언트가 문서의 일부분 or 특정 범위만 요청할 수 있도록 해줌
  - 클라이언트는 받다가 실패한 일부 엔터티를 요청할 수 있음
- ex) Range: bytes=4000-
  - 4000 바이트 이후의 부분
  - 문서의 크기를 모르므로 몇 바이트까지인진 명시 X
- 하나의 요청으로 여러 범위를 요청할 수도 있음
- 모든 서버가 범위 요청을 받아들일 수는 없지만 많은 경우 가능
  - Accept-Range 헤더를 포함시키는 방법으로 알려줌 (주로 바이트)
- 클라이언트의 범위 요청은 클라이언트와 서버가 같은 버전의 문서를 갖고 있을 때만 의미가 있음
  - 클라이언트와 서버 사이에서 교환하는 인스턴스 조작의 일종이므로

## 15.10 델타 인코딩

- 클라이언트가 최신 인스턴스를 요청 후 세 페이지 전체를 보내는 대신 사본에 대해 변경된 부분만을 서버가 보내면 빨라짐
  - 델타 인코딩은 변경된 부분에 대해서만 통신하여 전송량을 최소화하는 HTTP 프로토콜의 확장
- 델타 인코딩의 메커니즘
  - 클라이언트가 갖고 있는 페이지의 버전과 델타 버전을 적용하기 위해 알고 있는 알고리즘을 서버에게 말해줌
  - 서버는 자신이 클라이언트가 갖고 있는 버전을 갖고 있는지와 그 버전과 최신 버전 사이의 델타를 어떻게 계산할 것인지 체크
  - 두 객체의 차이점을 계산하는 여러 가지 알고리즘이 존재
  - 서버가 델타를 계산 후 클라이언트에게 보내주고 이를 알림
  - 페이지의 최신 버전에 대한 새 식별자를 새로 만들어질 페이지의 버전에 명시 (If-None-Match)에 담음
- 클라이언트는 서버에게 A-IM 헤더를 보내 자신이 페이지에 대한 델타를 받아들일 수 있음을 알려줄 수도 있음
  - Accept-Instance-Manipulation
  - 클라이언트는 델타에 대한 자신이 알고 있는 알고리즘을 이 헤더 안에 명시
- 서버는 클라이언트에게 보내주는 것들
  - 응답 코드 - 226 IM Used
  - 알고리즘을 명시한 IM 헤더
  - 새 ETag 헤더
  - 델타를 계산할 때 기반이 된 문서의 ETag를 지정한 Delta-Base 헤더
- 델타 인코딩에 사용되는 헤더들
  - ETag, If-None-Match, A-IM, IM, Delta-Base

### 15.10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기

- IANA에 등록된 인스턴스 조작의 종류
  - vcdiff : vcdiff 알고리즘을 이용한 델타
  - diffe : 유닉스 diff -e 명령을 이용한 델타
  - gdiff : gdiff 알고리즘을 이용한 델타
  - gzip : gzip 알고리즘을 이용한 압축
  - deflate : deflate 알고리즘을 이용한 압축
  - range : 현재 응답이 범위 선택에 대한 결과인 부분 콘텐츠 일 때 응답에서 사용
  - identit : 클라이언트가 identity 인스턴스 조작을 받아들일 의사기 있음을 말해줄 때 (A-IM 헤더에서)
- 클라이언트 측에서 '델타 적용기'가 델타를 취하여 그를 기저 문서에 적용하여 문서의 최신 인스턴스를 생성
- 압축을 극대화하기 위해 여러 번의 인스턴스 조작을 거칠 수 있음
- 델타 인코딩의 단점
  - 구현이 까다로움
  - 서버는 매 순간의 사본을 유지하고 있어야 함 -> 디스크 공간이 늘어남
