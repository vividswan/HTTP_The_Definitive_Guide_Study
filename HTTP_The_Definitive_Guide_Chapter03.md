# 3장 - HTTP 메시지

- HTTP 메시지는 무언가를 담아 보내는 소포와 같음

## 3.1 메시지의 흐름

- HTTP 메시지는 메타 정보와 데이터로 구성

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다

- 메시지가 원 서버로 향하는 것은 `인바운드`로 이동하는 것
- 처리가 끝난 후 메시지가 사용자 에이전트로 돌아오는 것은 `아웃바운드`로 이동하는 것

### 3.1.2 다운스트름으로 흐는 메시지

- 모든 메시지는 다운스트림으로 흐름
- 메시지의 발송자는 수신자의 업스트림

## 3.2 메시지의 각 부분

- HTTP 메시지는 단순한 데이터의 구조화된 블록
  - 메시지는 시작줄, 헤더 블록, 본문으로 이루어짐
- 시작줄과 헤더는 줄 단위로 분리된 아스키 문자열
  - 각 줄은 캐리지 리턴과 개행 문자로 끝남(CRLF)
- 엔티티 본문이나 메시지 본문은 선택적인 데이터 덩어리
  - 이진 데이터를 포함할 수도 있음

### 3.2.1 메시지 문법

- 모든 HTTP 메시지는 요청 메시지, 응답 메시지로 구분
- 요청 메시지의 형식
  - <메서드> <요청 URL> <버전>
  - <헤더>
  -
  - <엔터티 본문>
- 응답 메시지의 형식
  - <버전> <상태 코드> <사유 구절>
  - <헤더>
  -
  - <엔터티 본문>
- 메서드
  - 클라이언트 측에서 서버가 리소스에 대하 수행해 주길 바라는 동작
  - GET, HEAD, POST와 같이 한 단어
- 요청 URL
  - 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소
- 버전
  - HTTP의 버전
  - HTTP/<메이저>,<마이너>
  - 마이저, 마이너는 모두 정수
- 상태 코드
  - 요청 중에 무엇이 일어났는지 설명하는 세 자리 숫자
  - 코드의 첫 번째 자릿수는 상태의 일반적인 분류
- 사유 구절(reason-phrase)
  - 상태 코드의 의미를 사람이 이해할 수 있게 설명해 주는 문구
  - 사람에게 읽히기 위해서만 존재
  - 상태 코드가 같다면 사유 구절이 달라도 동등한 의미
- 헤더들
  - 이름, 콜론(:), 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들
  - 헤더의 목록은 빈 줄(CRLF)로 끝남
- 엔터티 본문
  - 임의의 데이터 블록을 포함 (때때론 그냥 CRLF)
  - 헤더나 엔티티 본문이 없더라도 HTTP 헤더의 집합은 항상 빈 줄로 끝나야 함 (호환을 위해 이 규칙을 잘 지키지 않아도 받아들일 수 있어야 함)

### 3.2.2 시작줄

- 모든 HTTP 메시지는 시작줄로 시작
- 요청줄
  - 요청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁
  - 모든 필드는 공백으로 구분
- 응답줄
  - 응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려줌
  - HTTP 버전, 상태 코드, 텍스트로 된 사유 구절
  - 모든 필드는 공백으로 구분
- 메서드
  - 요청의 시작줄은 메서드로 시작
  - 서버에게 무엇을 해야 할지 말해줌
  - GET : 서버에서 어떤 문서를 가져옴
  - HEAD : 서버에서 어떤 문서에 대한 헤더만 가져옴
  - POST : 서버가 처리해야 할 데이터를 보냄 (본문 필요)
  - PUT : 서버에 요청 메시지의 본문을 저장 (본문 필요)
  - TRACE : 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적
  - OPTIONS : 서버가 어떤 메서드를 수행할 수 있는지 확인
  - DELETE : 서버에서 문서를 제거
  - 한 서버만의 메서드를 추가로 구현 가능 (확장 메서드)
- 상태 코드
  - 클라이언트에게 무엇이 일어났는지 말해줌 (응답의 시작줄에 위치)
  - 숫자(세 자리 숫자)로 된 코드와 문자열(사유 구절)로 구성
  - 100-101 : 정보
  - 200-206 : 성공
  - 300-305 : 리다이렉션
  - 400-415 : 클라이언트 에러
  - 500-505 : 서버 에러
  - 상태 코드 확장 시 포함되는 범주를 확인하고 추가할 것
  - 많이 쓰이는 상태 코드들 : 200(OK), 401(Unauthorized), 404(Not Found)
- 사유 구절
  - 응답 시작줄의 마지막 구성요소
  - 상태 코드와 일대일로 대응 (상태 코드의 쉬운 버전)
  - 엄격한 규칙 제공 X
- 버전 번호
  - HTTP/x.y 형식
  - 요청과 응답 메시지 양쪽 모두에 기술
  - 애플리케이션들에게 대화 상대의 능력과 메시지의 형식에 대한 단서 제공
  - 분수로 다루어지지 않음에 주의
    - HTTP/2.22는 HTTP/2.3보다 크다.

### 3.2.3 헤더

- 시작줄 다음에는 0개 혹은 여러 개의 HTTP 헤더가 옴
- 이름/값 쌍의 목록
- 헤더 분류
  - HTTP 헤더 명세서는 여러 헤더 필드를 정의, 자유롭게 자신만의 헤더 만들기도 가능
- 일반 헤더
  - 요청과 응답 양쪽에 모두 나타날 수 있음
- 요청 헤더
  - 요청에 대한 부가 정보를 제공
- 응답 헤더
  - 응답에 대한 부가 정보를 제공
- Entity 헤더
  - 본문 크기, 콘텐츠, 리소스 그 자체를 서술
- 확장 헤더
  - 명세에 정의되지 않은 새로운 헤더
- 각 헤더는 간단한 문법을 가짐
  - 이름, 쉼표, 공백(생략 가능), 필드 값, CRLF가 순서대로 옴
- 헤더를 여러 줄로 나누기
  - 추가 줄 앞에 최소 하나의 스페이스 혹은 탭 문자를 붙여서 여러 줄로 쪼갤 수 있음

### 3.2.4 엔터티 본문

- HTTP 메시지의 세 번째 부분
- HTTP 메시지의 화물
- 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 실어 나를 수 있음

### 3.2.5 버전 0.9 메시지

- HTTP 프로토콜의 초기 버전, 단순한 프로토콜로 되어있음
- 요청은 메서드와 URL만 갖고 있음
- 응답은 엔터티로만 되어있음
- 단순함 때문에 많은 상황에 대응 불가능

## 3.3 메서드

- 모든 서버가 모든 메서드를 구현하지는 않음
- 메서드는 대부분 제한적(서버 설정에 따라)으로 사용됨

### 3.3.1 안전한 메서드(Safe Method)

- `GET`, `HEAD` 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 작용도 없음
  - 이는 안전한 메서드
- 작용이 없다는 것은 HTTP 요청의 결과로 인해 서버에서 일어나는 일은 아무것도 없음을 의미

### 3.3.2 GET

- 가장 흔히 쓰이는 메서드
- 서버에서 리소스를 달라고 요청하기 위해 사용

### 3.3.3 HEAD

- 서버는 응답으로 헤더만을 돌려줌
- 엔터티 본문은 결코 반환되지 않음
  - 리소스를 실제로 가져올 필요 없이 헤더만을 조사할 수 있도록 해줌
- 리소스를 가져오지 않고도 그에 대해 무엇인가(타입 등)를 알아낼 수 있음
- 응답의 상태 코드를 통해 객체의 존재 유무 확인 가능
- 헤더를 확인하여 리소스가 변경되었는지 검사 가능
- 서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 됨

### 3.3.4 PUT

- PUT 메서드는 서버에 문서를 씀
- PUT 메서드의 의미는 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것
- PUT은 콘텐츠를 변경할 수 있기 때문에 보통 사용자 인증을 요구함

### 3.3.5 POST

- 서버에 입력 데이터를 전송하기 위해 설계
  - HTML 폼을 지원하기 위해 흔히 사용됨
- 폼에 담긴 데이터는 서버로 전송되고 서버는 이를 모아 필요로 하는 곳에 보냄

### 3.3.6 TRACE

- 방화벽, 프락시, 게이트웨이의 등을 거쳐 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줌
- 목적지 서버에서 `루프백(loopback)` 진단을 실시 후 요청의 마지막 단계에 있는 서버에서 자신이 받은 요청 메시지를 본문에 넣어 응답
  - 클라이언트는 모든 단계의 요청/응답 연쇄를 따라갈 수 있고 변경 가능
- TRACE 메서드는 주로 진단을 위해 사용
- TRACE 요청을 어떻게 처리할 것인지는 중간 애플리케이션이 결정을 내림
- TRACE 요청은 어떠한 엔터티 본문도 보낼 수 없음

### 3.3.7 OPTIONS

- 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어봄
- 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있음

### 3.3.8 DELETE

- 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청
- 클라이언트는 삭제가 수행되는 것을 보장 못 함
  - HTTP 명세에서 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용

### 3.3.9 확장 메서드

- HTTP는 필요에 따라 확장 가능
- 확장 메서드는 HTTP/1.1 명세에 정의되지 않은 메서드
- 대표적인 예
  - LOCK : 사용자의 리소스를 잠글 수 있게 해줌
  - MKCOL : 사용자가 문서를 생성할 수 있게 해줌
  - COPY : 서버에 있는 리소스를 복사
  - MOVE : 서버에 있는 리소스를 옮김
- 확장 메시지는 엄격하게 보내고 관대하게 받아들일 것

## 3.4 상태 코드

- HTTP 상태 코드는 크게 다섯 가지로 나뉨

### 3.4.1 100-199: 정보성 상태 코드

- 정보성 상태 코드는 HTTP/1.1에서 도입
- 100 (Continue) : 요청의 시작 부분의 일부가 받아짐 & 나머지를 계속 이어서 보내야 함
  - 클라이언트가 엔터티 본문을 전송하기 전 서버가 받아들일 것인지 확인하는 작업의 최적화
- 101 (Switching Protocols) : 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미
- 클라이언트와 100 Continue
  - 클라이언트가 100 Continue 응답을 원하면 100-continue로 Expect 요청 헤더를 보내야 함
  - 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않으려는 목적으로 사용
  - 약간의 타임아웃 후에 클라이언트는 그냥 엔터티를 보내야 함
- 서버와 100 Continue
  - 서버는 100-continue로 Expect 요청 헤더를 받으면 100 Continue 응답 or 에러 코드로 답해야 함 (의도하지 않은 클라이언트에게는 절대 보내면 안 됨)
  - 엔터티의 일부나 전체를 수신했다면 이 상태 코드가 필요 없음
  - 서버가 요청을 끝까지 다 읽은 후에는 그 요청에 대한 최종 응답을 보내야 함
  - 100-continue로 Expect 요청 헤더를 받은 상태에서 엔터티 본문을 읽기 전에 요청을 끝내기로 결정했을 시 서버는 그냥 응답을 보내고 연결을 닫아서는 안 됨
- 프락시와 100 Continue
  - 다음 홉 서버가 HTTP/1.1을 따르거나 어떤 버전을 따르는지 모른다면 Expect 헤더를 포함시켜 요청을 다음으로 전달해야 함 (1.1보다 이전 버전의 HTTP라면 417 Expectation Faild 에러로 응답)
  - 프락시가 HTTP/1.0 이하의 버전을 따르는 클라이언트를 대신하여 100 값을 보낸다면 프락시는 100 Continue 응답을 클라이언트에게 전달하면 안 됨
  - 프락시가 다음 홉 서버들에 대한 상태 몇 가지와 지원 HTTP 버전을 기억해둔다면 요청을 더 잘 다룰 수 있는 이득이 생김

### 3.4.2 200-299: 성공 상태 코드

- 대응하는 성공을 의미하는 상태 코드들
- 200 (OK) : 요청 정상 & 엔터티 본문은 요청된 리소스 포함
- 201 (Create) : 서버 개체를 생성하라는 요청을 위한 것
- 202 (Accepted) : 요청은 받아들여졌으나 아직 그에 대한 동작을 서버가 수행하지 않은 상태
- 203 (Non-Authoritative Information) : 엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 온 상태
- 204 (No Content) : 응답 메시지는 헤더와 상태줄을 포함하지만 엔터티 본문은 포함 X
- 205 (Reset Content) : 브라우저에 현재 페이지에 있는 HTML 폼에 채워진 모든 값을 비우라고 말함
- 206 (Partial Content) : 부분 혹은 범위 요청이 성공

### 3.4.3 300-399: 리다이렉션 상태 코드

- 리소스에 대해 다른 위치를 사용하라고 말해주거나 리소스 대신 다른 대안 응답 제공
- 리다이렉션 상태 코드 중 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본과 원래 서버를 비교 후 유효한지 확인
  - ex) If-Modified-Since (변한 것이 없다면 콘텐츠 x, 304)
- HEAD가 아닌 요청에 대해 리다이렉트 될 URL에 대한 링크와 설명을 포함시킬 것
- 300 (Multiple Choices) : 클라이언트가 동시에 여러 리소스를 가리키는 URL 요청 시 리소스의 목록과 함께 반환
- 301 (Moved Permanently) : 요청한 URL이 옮겨졌을 때 사용 (Location에 현재 리소스 존재 URL을 포함해야 함)
- 302 (Found) : 301과 같지만 Location 헤더의 URL은 임시적
- 303 (See Other) : 리소스를 다른 URL에서 가져와야 한다고 말해주고자 할 때
  - Location 헤더에 새 URL
  - POST 요청에 대한 응답이 주 목적
- 304 (Not Modified) : 조건부 요청에서 리소스가 최근에 수정된 일이 없음을 보여주기 위해 (이 상태 코드 동반 시 엔터티 본문을 가져서는 안 됨)
- 305 (User Proxy) : 리소스가 반드시 프락시를 통해서 접근되어야 함을 나타낼 때
  - 클라이언트는 모든 요청에 대해 프락시를 통해야 한다고 상정하지 않음
- 306 (사용되지 않음)
- 307 (Temporary Redirect) : 301 상태 코드와 비슷하지만 Location 헤더로 주어진 URL 리소스는 임시로 가리키기 위한 목적
- 302, 303, 307 상태 코드
  - HTTP/1.0에서는 POST 요청 후 302 코드가 담긴 응답을 받으면 GET 요청으로 클라이언트가 따라감
  - HTTP/1.1은 이러한 명세는 303코드
  - 혼란을 막기 위해 HTTP/1.1의 일시적인 리다이렉트는 307 상태 코드, HTTP/1.0을 위해 302를 남겨둘 수도 있음

### 3.4.4 400-499: 클라이언트 에러 상태 코드

- 다양한 클라이언트 에러 상태 코드가 존재
- 400 (Bad Request) : 클라이언트가 잘못된 요청을 보냄
- 401 (Unauthorized) : 리소스를 얻기 전에 클라이언트에게 스스로 인증하라고 요구
- 402 (Payment Required) : 현재 쓰이진 않지만 미래 가능성을 위해 준비
- 403 (Forbidden) : 요청이 서버에 의해 거부되었을 때, 보통 서버가 거절의 이유를 숨기고 싶을 때 사용
- 404 (Not Found) : 서버가 요청한 URL을 찾을 수 없을 때
- 405 (Method Not Allowed) : 요청한 URL에 대해 지원하지 않는 메서드로 요청받았을 때 사용, Allow 헤더로 어떤 메서드가 사용 가능한지 알려줌
- 406 (Not Acceptable) : 클라이언트가 원하는 종류의 엔터티를 매개변수로 명시했을 때 주어진 리소스 중 클라이언트가 받아들일 수 있는 것이 없는 경우 사용
- 407 (Proxy Authentication Required) : 401 상태 코드와 같으나 리소스에 대해 인증을 요구하는 프락시 서버를 위해 사용
- 408 (Request Timeout) : 클라이언트의 요청을 완수하기에 시간이 너무 긴 경우 사용 후 연결을 서버에서 끊을 수 있음
- 409 (Conflict) : 요청이 리소스에 대해 일으킬 수 있는 몇몇 충돌을 지칭하기 위해 사용
- 410 (Gone) : 404와 비슷, 서버가 한때 그 리소스를 갖고 있었다는 점이 다름
- 411 (Length Required) : 서버가 요청 메시지에 Content-Length 헤더가 있을 경우 요구할 때 사용
- 412 (Precondition Failed) : 클라이언트가 조건부 요청을 했는데 그중 하나가 실패했을 때 사용
- 413 (Request Entity Too Large) : 서버가 처리할 수 있거나 처리하고자 하는 한계를 넘은 크기의 요청을 클라이언트가 보냈을 때 사용
- 414 (Request URI Too Long) : 서버가 처리할 수 있거나 처리하고자 하는 한계를 넘은 크기의 URL을 클라이언트가 보냈을 때 사용
- 415 (Unsuppoted Media Type) : 서버가 이해하거나 지원하지 못하는 내용 유형의 엔터티를 클라이언트가 보냈을 때 사용
- 416 (Requested Range Not Satisfiable) : 요청 메시지가 리소스의 특정 범위를 요청했는데, 그 범위가 잘못되었을 때 사용
- 417 (Expectation Failed) : 요청에 포함된 Expect 요청 헤더에 서버가 만족시킬 수 없는 기대가 담겨있는 경우 사용

### 3.4.5 500-599: 서버 에러 상태 코드

- 클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우
- 500 (Internal Server Error) : 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때
- 501 (Not Implemented) : 클라이언트가 서버의 능력을 넘은 요청을 했을 때 사용 (서버가 지원하지 않는 메서드 등..)
- 502 (Bad Gateway) : 프락시 같은 서버가 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때
- 503 (Service Unavailable) : 현재는 서버가 요청을 처리해 줄 수 없지만 나중에는 가능함을 의미하고자 할 때
- 504 (Gateway Timeout) : 상태 408과 비슷하지만 다른 서버에게 요청을 보내고 응답을 기다리다 타임아웃이 발생한 경우
- 505 (HTTP Version Not Supported) : 서버가 지원할 수 없거나 지원하지 않으려고 하는 버전의 프로토콜로 된 요청을 받았을 때

## 3.5 헤더

- 일반 헤더(General Headers)
  - 클라이언트, 서버 양쪽 모두가 사용
  - 다양한 목적으로 사용
- 요청 헤더(Request Headers)
  - 요청 메시지를 위한 헤더
  - 클라이언트가 서버에게 받고자 하는 데이터의 타입이 무엇인지 등
- 응답 헤더(Response Headers)
  - 클라이언트에게 정보를 제공하기 위한 헤더
- 엔터티 헤더(Entity Headers)
  - 엔터티 본문에 대한 헤더
  - 엔터티 본문에 들어있는 데이터의 타입 등..
- 확장 헤더(Extension Headers)
  - 아직 승인된 HTTP 명세에는 추가되지 않은 비표준 헤더
  - 의미를 모른다 할지라도 용인하고 전달해야 함

### 3.5.1 일반 헤더

- 아주 기본적이고 유용한 정보 제공
  - Connection, Date, MIME-Version, Trailer chunked transfer, Transfer-Encoding, Upgrade, Via
- 일반 캐시 헤더
  - 최신 버전의 HTTP는 매우 풍부한 캐시 매개변수의 집합을 가지고 있음
  - Cache-Control, Pragma(deprecated 예정)

### 3.5.2 요청 헤더

- 요청 메시지에서만 의미를 가짐
- Client-IP, From, Host, Referer, UA-Color, UA-CPU, UA-Disp, UA-OS, UA-Pixels, User-Agent
- Accept 관련 헤더
  - 클라이언트가 무엇을 원하고 무엇을 할 수 있고, 무엇을 원치 않는지 알려줄 수 있음
  - Accept, Accept-Charset, Accept-Encoding, Accept-Language, TE
- 조건부 요청 헤더
  - 클라이언트가 요청에 몇몇 제약을 넣을 때
  - Expect, If-Match, If-Modified-Since, If-None-Match, If-Range, If-Unmodified-Since, Range
- 요청 보안 헤더
  - HTTP는 자체적으로 요청을 위한 간단한 인증 요구/응답 체계를 갖고 있음
  - Authorization, Cookie, Cookie2
- 프락시 요청 헤더
  - 프락시의 기능을 돕기 위한 몇몇 헤더들
  - Max-Forwards, Proxy-Authorization, Proxy-Connection

### 3.5.3 응답 헤더

- 클라이언트에게 부가 정보를 제공
- Age, Public, Retry-Afetr, Server, Title, Warning
- 협상 헤더
  - 클라이언트가 어떤 것을 택할 건지에 대한 협상을 할 수 있도록 지원
  - Accept-Ranges, Vary
- 응답 보안 헤더
  - HTTP 인증 요구/응답 체계의 응답 측에 해당하는 보안 헤더들
  - Proxy-Authenticat, Set-Cookie, Set-Cookie2, WWW-Authenticate

### 3.5.5 엔터티 헤더

- 양 타입의 메시지에 모두 나타날 수 있음
- 엔터티와 그것의 내용물에 대한 광범위한 정보
- Allow, Location
- 콘텐츠 헤더
  - 엔터티의 콘텐츠에 대한 구체적인 정보를 제공
  - Content-Base, Content-Encoding, Content-Language, Content-Length, Content-Location, Content-MD5, Content-Range, Content-Type
- 엔터티 캐싱 헤더
  - 엔터티 캐싱에 대한 정보를 제공 (리소스에 대해 캐시 된 사본의 유효성 등)
  - ETag, Expires, Last-Modified
