# 10장 - HTTP/2.0

- HTTP/2.0 만드는 작업은 진행 중

## 10.1 HTTP/2.0의 등장 배경

- HTTP/1.1은 회전 지연 존재
  - 응답을 받아야만 그다음 요청을 보낼 수 있기 때문
  - 병렬 커넥션이나 파이프라인 커넥션은 근본적인 해결책 X
- 구글의 SPDY를 기반으로 HTTP/2.0 설계
  - 헤더를 압축하여 대역폭 절약
  - 하나의 TCP 커넥션에 여러 요청을 동시에 보냄
  - 클라이언트 요청 없어도 서버가 능동적으로 리소스를 푸시

## 10.2 개요

- HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작
  - 클라이언트가 커넥션을 초기화함
- HTTP/2.0 요청과 응답은 길이가 정의된 한 개 이상의 프레임에 담김
  - 이때 HTTP 헤더는 압축
- 스트림을 통해 요청과 응답이 보내짐
  - 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있음
  - 스트림에 대한 우선순위 부여도 가능
- 새로운 상호작용 모델인 서버 푸시를 도입
  - 서버가 능동적으로 클라이언트에게 리소스 송신 가능
- 호환성을 위해 HTTP/1.1의 요청, 응답 메시지 같도록 유지
  - 다만 Content-Length -> :content-length, 404는 :status 헤더로 표현하는 것으로 바뀜

## 10.3 HTTP/1.1과의 차이점

### 10.3.1 프레임

- HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송
- 모든 프레임은 8바이트 크기의 헤더로 시작
  - 뒤이어 최대 16383바이트 크기의 페이로드가 옴
- 프레임 헤더의 각 필드
  - R: 예약된 2비트 필드, 반드시 0, 값의 의미 정의 X
  - 길이: 페이로드의 길이, 14비트 무부호 정수
  - 종류: 프레임의 종류
  - 플래그: 8비트 플래그, 프레임의 종류에 따라 의미가 다름
  - R: 예약된 1비트, 값의 정의 X, 반드시 0
  - 스트림 식별자: 31비트 스트림 식별자.
- HTTP/2.0은 DATA, HEADERS, PRIORTY, RST_STREAM, SETTINGS, PUSH_PROMISE, PING, GOAWAY, WINDOW_UPDATE, CONTINUATION 이라는 10가지 프레임을 정의

### 10.3.2 스트림과 멀티플렉싱

- 스트림
  - HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스
  - 한 쌍의 HTTP 요청과 응답이 하나의 스트림을 통해 이루어짐
- HTTP/1.1은 응답이 도착해야 같은 TCP 커넥션으로 다시 요청을 보낼 수 있음
  - 여러 개의 커넥션 or 파이프라인 커넥션으로 회전 지연을 줄이려 함
- HTTP/1.1과 다르게 HTTP/2.0에서는 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있음
- 스트림은 우선순위도 가질 수 있음
  - 우선순위에 따르는 것은 의무사항이 아니기 때문에 보장은 없음
- 모든 스트림은 31비트의 무부호 정수로 된 고유한 식별자를 가짐
  - 스트림이 클라이언트에 의해 초기화되었다면 이 식별자는 반드시 홀수, 서버라면 짝수
  - 이전에 만들어졌거나 예약된 스트림들의 식별자보다 새로 만들어지는 스트림의 식별자가 커야 됨
  - 규칙 어길 시 에러 코드가 PROTOCO_ERROR인 커넥션 에러로 응답
- 서버, 클라이언트는 서로 협상 없이 일반적으로 스트림 생성
  - 협상 시간 줄임
- 한번 사용한 스트림 식별자는 재사용 불가 X
  - 고갈 시 다시 커넥션 맺기
- WINDOW_UPDATE 프레임을 이용한 흐름 제어로 스트림끼리의 간섭을 막아 줌

### 10.3.3 헤더 압축

- HTTP/1.1의 헤더는 아무런 압축 없이 그대로 전송
- 수십에서 수백 번의 요청을 보내기 때문에 HTTP/2.0은 헤더를 압축
  - HPACK 명세에 정의된 방법으로 압축 후 '헤더 블록 조각'으로 쪼개져서 전송
  - 받는 쪽에서 이 조각을 이은 후 압축 해제
- HPACK은 압축 콘텍스트를 사용
  - 수신한 헤더의 압축을 풀면 압축 콘테스트가 바뀜
  - 송신 측은 수신 측의 압축 헤더에 의해 압축 콘텍스트가 변경되었다고 가정
  - 수신 측은 반드시 압축 해제를 수행해야 하고 그럴 수 없을 시 COMPRESSION_ERROR와 함께 커넥션 해제

### 10.3.4 서버 푸시

- HTTP/2.0는 하나의 요청에 대해 응답으로 여러 개의 리소스를 보내도록 해줌
  - 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 때 유용
  - 다시 요청하여 발생하는 회전 지연 줄여줌
- 서버는 먼저 클라이언트에게 PUSH_PROMISE 프레임을 보내어 자원 푸시를 선언
  - 클라이언트가 자원을 별도로 또 요청하게 되는 상황 회피하기 위해
- 클라이언트는 자원 푸시 프레임을 받게 되면 해당 프레임의 스트림은 '예약됨(원격)' 상태가 됨
- 클라이언트는 예약 상태에서 RST_STREAM 프레임을 보내어 푸시 거절 가능
  - 이 프레임을 보낼 시 스트림은 즉각 닫히게 됨
- 스트림이 닫히기 전까지 서버가 푸시 하려고 하는 리소스를 클라이언트가 요청해서는 X
- 서버 푸시 시 주의 사항
  - 중간 프락시가 서버로부터 추가 리소스를 전달하지 않거나 서버에게 받지 않은 리소스를 전달할 수도 있음
  - 서버는 안전, 캐시 가능, 본문을 포함하지 않은 요청에 대해서만 푸시 가능
  - 푸시 할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것만
  - 서버가 푸시 한 리소스를 클라이언트에서 동일 출처 정책에 따라 검사할 것
  - SETTINGS_ENABLE_PUSH를 0으로 설정하면 서버 푸시를 끌 수 있음

## 10.4 알려진 보안 이슈

### 10.4.1 중개자 캡슐화 공격(Intermediary Encapsulation Attacks)

- HTTP/2.0은 HTTP/1.1과 다르게 헤더 필드의 이름과 값을 바이너리로 인코딩
  - 헤더 필드로 어떤 문자열이든 사용할 수 있게 해줌
- 정상적인 HTTP/2.0 요청, 응답이 불법적이거나 위조된 HTTP/1.1로 번역될 수 있음
- HTTP/1.1 메시지를 HTTP/2.0 메시지로 번역하는 과정에선 이러한 문제 X

### 10.4.2 긴 커넥션 유지로 인한 개인 정보 노출 우려

- HTTP/2.0은 회전 지연 감소를 위해 긴 유지의 커넥션을 염두
  - 개인 정보 유출에 악용 가능
- 짧게 유지되는 커넥션에선 위험이 적음
