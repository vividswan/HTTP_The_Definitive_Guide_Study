# 17장 - 내용 협상과 트랜스코딩

- 내용 협상
  - 하나의 URL이 여러 가지 리소스 중 적합한 것에 대응되도록 함
  - variant : 서로 다른 버전
  - 내용 협상에 대한 응답으로 트랜스코딩도 가능

## 17.1 내용 협상 기법

- 클라이언트 주도
  - 서버가 선택지를 보내줌
  - 서버 입장에선 구현이 쉬움
  - 대기시간이 증가 (두 번의 요청이 필요하므로)
- 서버 주도
  - 클라이언트의 요청 헤더를 서버가 검증
  - q값 메커니즘, Vary 헤더 등으로 빠르게 처리
  - 결정이 뻔하지 않을 시 서버의 추측이 필요
- 투명
  - 투명한 중간 장치가 서버를 대신하여 협상 (주로 프락시)
  - 클라이언트 주도 보다 빠름
  - 정형화된 명세가 없음

## 17.2 클라이언트 주도 협상

- 가장 구현하기 쉽고 최선의 사본이 선택됨
- 각 페이지의 두 번의 요청이 필요하다는 것이 단점
- 여러 버전에 대한 설명과 링크가 담긴 HTML 페이지를 전달하는 방식
- 300 Multiple Choices 응답 코드로 HTTP/1.1 응답을 돌려주는 방식
- 여러 개의 URL을 요구한다는 단점도 있음

## 17.3 서버 주도 협상

- 클라이언트 주도 협상의 추가 커뮤니케이션을 줄이기 위한 방법
- 클라이언트가 자신이 무엇을 선호하는지 충분한 정보를 주어야 함
- 메커니즘
  - 내용 협상 헤더들을 살펴봄 (Accept 관련)
  - 내용 협상 헤더 외의 다른 헤더들을 살펴봄 (ex. 클라이언트의 User-Agent 헤더)

### 17.3.1 내용 협상 헤더

- Accept
  - 서버가 어떤 미디어 타입으로 보내야 하는지
- Accept-Language
  - 서버가 어떤 언어로 보내도 되는지
- Accept-Charset
  - 서버가 어떤 차셋으로 보내도 되는지
- Accept-Encoding
  - 서버가 어떤 인코딩으로 보내도 되는지
- 클라이언트의 선호에 가장 잘 맞는 문서를 제공하기 위한 목적
  - 이 점이 엔터티 헤더들과는 다름
- 클라이언트는 요청마다 선호 정보를 보내야 함
- 선호에 대한 품질 값을 이용해 전달도 가능

### 17.3.2 내용 협상 헤더의 품질값

- 품질값을 통해 여러 선택 가능한 항목을 선호도와 함께 나열 가능
- q 값은 0.0부터 1.0까지의 값을 가질 수 있음
  - 1.0이 가장 높음
  - 0.0이 가장 낮음
- 선호에 대응하는 문서가 서버에 없을 시 문서를 고치거나 트랜스코딩 가능

### 17.3.3 그 외의 헤더들에 의해 결정

- User-Agent와 같은 클라이언트의 다른 요청 헤더들을 통해 알맞은 요청을 만들어내려고 시도 가능
- Vary 헤더는 캐시와 클라이언트, 다운스트림 프락시에게 서버가 내줄 응답의 최선의 버전을 결정하기 위해 어떤 요청 헤더를 참고하고 있는지 말해줌

### 17.3.4 아파치의 내용 협상

- 아파치 웹 서버에서 내용 협상을 지원하려면 각각의 버전에 해당하는 파일들을 아파치 서버의 적절한 디렉토리에 모두 넣어줘야 함
- 넣어준 뒤 다음의 두 가지 방법 중 한 가지 방법으로 내용 협상을 동작
  - 배리언트(variant)를 갖는 웹 사이트의 각 URI를 위한 type-map 파일을 만듦
  - 아파치가 그 디렉터리에 대해 자동으로 type-map 파일을 생성하도록 하는 MultiViews 지시어를 킴
- type-map 파일 사용하기
  - 서버 설정 파일에 type-map 파일들을 위한 파일 접미사를 명시한 핸들러를 추가
  - tpye-map 파일들을 통해 아파치에서 내용 협상에 따른 파일 지원 가능
- MultiViews 사용하기
  - access.conf 파일의 적절한 절에 Options 지시어를 이용해서 웹 사이트를 포함한 디렉터리에 MultiViews를 반드시 켜야 함
  - 이름에 근거해서 서버는 각 파일에 대응하는 적절한 내용 협상 헤더를 추측

### 17.3.5 서버 측 확장

- 마이크로소프트의 액티브 서버 페이지와 같이 서버 쪽에서 확장을 하는 방법도 존재

## 17.4 투명 협상

- 클라이언트 입장에서 협상하는 중개자 프락시를 두는 방식
- 서버 주도 협상으로 인한 부하 제거
- 서버는 어떤 요청 헤더를 검사해야 하는지 프락시에게 말해줄 수 있어야 함
- HTTP/1.1 명세는 투명 협상에 대한 어떤 메커니즘도 정의 X
  - 대신 Vary 헤더를 정의
- 캐시 안에 있는 범용 트랜스코더는 특정 서버에 국한 X, 어떤 서버의 콘텐츠든 트랜스코딩 가능

### 17.4.1 캐시와 얼터네이트(alternate)

- 캐시는 서버가 응답을 돌려줄 때 사용했던 의사 결정 로직의 상당 부분을 그대로 사용
- 캐시는 같은 URL에 대해 서버와 같은 응답을 위해 두 개의 다른 문서를 가질 수 있음
  - 다른 버전을 배리언트나 얼터네이트로 부름

### 17.4.2 Vary 헤더

- 서버가 반환할 페이지 판단을 위해 Accept와 같은 헤더 외에 다른 헤더를 사용 중이라면 캐시도 반드시 알아야 함
- HTTP Vary 응답 헤더
  - 서버가 문서를 선택하거나 커스텀 콘텐츠를 생성할 때 고려한 클라이언트 요청 헤더 모두를 나열
- 캐시가 문서를 클라이언트에게 제공해 주기 전 반드시 캐시 된 응답 안에 서버가 보낸 Vary 헤더 유무를 확인
- Vary 헤더가 존재 시 캐시는 반드시 캐시 된 배리언트와 함께 요청 헤더와 그에 알맞은 서버 응답 헤더 양쪽 모두를 저장
  - 알맞은 문서가 없을 시 서버에서 가져옴

## 17.5 트랜스코딩

- 트랜스코딩
  - 서버가 클라이언트의 요구에 맞는 문서를 갖고 있지 않을 시 이론적으로 서버는 기존의 문서를 클라이언트가 사용할 수 있는 것을 변환 가능
  - 포맷 변환, 정보 합성, 내용 주입의 세 종류

### 17.5.1 포맷 변환

- 클라이언트가 볼 수 있도록 한 포맷에서 다른 포맷으로 변환
- 내용 변환 혹은 트랜스코딩은 콘텐츠 인코딩이나 전송 인코딩과는 다름
  - 전자 : 특정 접근 장치에서 볼 수 있도록 하기 위함
  - 후자 : 콘텐츠의 더 효율적인 혹은 안전한 전송을 위한 것

### 17.5.2 정보 합성

- 문서에서 정보의 요점을 추출하는 것
- 각 절의 제목에 기반한 문서의 개요 생성, 페이지의 광고 및 로고 제거 등 ...
- 문서의 핵심을 요약할 때도 유용

### 17.5.3 콘텐츠 주입

- 내용 주입 트랜스 코딩
  - 자동 광고 생성, 사용자 추적 시스템 등 ...
- 동적으로 추가가 이루어짐

### 17.5.4 트랜스코딩 vs. 정적으로 미리 생성해놓기

- 정적으로 미리 생성하는 방식은 현실적인 기법이 X
  - 작은 변화에도 여러 페이지의 수정이 요구
  - 더 많은 공간 필요
  - 올바른 것을 골라서 제공해 주는 프로그래밍이 어려움
