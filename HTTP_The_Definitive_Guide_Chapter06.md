# 6장 - 프락시

- 프락시는 클라이언트와 서버 사이에 위치하는 중개자

## 6.1 웹 중개자

- 웹 프락시가 있다면 클라이언트는 HTTP 서버와 직접 얘기하는 대신 프락시와 이야기
  - 프락시가 제공하는 좋은 서비스 이용 가능
- 프락시는 웹 서버이자 웹 클라이언트
  - 클라이언트에겐 웹 서버와 같은 역할
  - 서버에겐 HTTP 클라이언트처럼 동작해야 함

### 6.1.1 개인 프락시와 공유 프락시

- 공용 프락시
  - 대부분의 프락시는 공용이며 공유된 프락시
  - 중앙 집중형 프락시가 비용 효율이 높음
  - 공통된 요청에서 이득을 취할 수 있는 프락시 애플리케이션은 이용자가 많을수록 유리
- 개인 프락시
  - 개인 전용 프락시
  - 흔하지는 않지만 꾸준히 사용되고 있음
  - 어떤 개인 프락시는 작은 프락시를 사용자의 컴퓨터에서 직접 실행하는 방식으로 사용

### 6.1.2 프락시 대 게이트웨이

- 프락시 : 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결
- 게이트웨이 : 서로 다른 프로토콜을 사용하는 둘 이상을 연결
  - 서로 다른 프로토콜이어도 트랜잭션을 완료할 수 있도록 프로토콜 변환기로 동작
- 실질적으로 둘의 차이는 모호
  - 프락시가 서로 다른 버전의 HTTP와 같은 프로토콜 변환을 하기도 함
  - 상용 프락시 서버는 SSL 보안 프로토콜, SOCKS 방화벽, FTP 접근 등을 구현

## 6.2 왜 프락시를 사용하는가?

- 프락시 서버는 실용적이고 유용한 것들을 함
  - 보안 개선, 성능 향상, 비용 절약
- 프락시 서버는 모든 HTTP 트래픽을 들여다보거나 건들 수 있음
  - 이것으로 부가 가치를 줄 수 있음
- 어린이 필터
  - 필터링 프락시
  - 교육 콘텐츠에는 제한 없는 접근, 어린이에게 부적절한 사이트의 접근은 강제로 거부 가능
- 문서 접근 제어자
  - 리소스에 대한 단일한 접근 제어 전략 & 감사 추적
  - 따로따로 하지 않고 중앙 프락시 서버에서 접근 제어 설정
- 보안 방화벽
  - 보안을 강화하기 위해 사용
  - 나가고 들어오는 응용 레벨 프로토콜의 흐름을 한 지점에서 통제
  - 바이러스를 제거할 수 있는 후크 제공
- 웹 캐시
  - 인기 있는 문서의 로컬 사본을 관리하고 요청 시 제공
- 대리 프락시(Surrogate)
  - 리버스 프록시 혹은 서버 가속기
  - 웹 서버인 것처럼 위장
  - 요청받은 콘텐츠의 위치를 찾아내기 위해 다른 서버와 커뮤니케이션 시작
- 콘텐츠 라우터
  - 요청을 특정 웹 서버로 요청
  - 여러 맞춤형 서비스 구현 가능 (가까운 캐시로 더 높은 성능, 필터링 서비스 등등)
- 트랜스코더
  - 클라이언트에게 전달하기 전 본문 포맷 수정 가능 (트랜스 코딩)
  - 트랜스코딩은 단순한 변환, 트렌스레이션은 데이터의 보다 두드러진 매체 변경으로 정의하기도 함
  - 이미지 압축, 텍스트 파일 압축, 작은 텍스트로 줄인 웹페이지 생성 등등 ..
- 익명화 프락시(Anonymizer)
  - 신원을 식별할 수 있는 특성들을 적극적으로 제거 (브라우징 경험의 질이 떨어질 수도 있음)
  - 개인 정보 보호 & 익명성 보장에 기여

## 6.3 프락시는 어디에 있는가?

- 프락시는 어디에든 배치 가능

### 6.3.1 프락시 서버 배치

- 출구(Egress) 프락시
  - 프락시를 클라이언트의 로컬 네트워크의 출구에 박아 넣음
  - 방화벽 제공, 인터넷 요금 절약, 트래픽 성능 개선 등이 목적
  - 초등학교에서 부적절한 콘텐츠를 브라우징 하는 것을 막을 수도 있음
- 접근(입구) 프락시
  - ISP 접근 지점에 위치하도록 하는 프락시
  - ISP는 캐시 프락시를 사용해 문서들의 사본을 저장하여 다운로드 속도 개선 및 인터넷 대역폭 비용을 줄임
- 대리 프락시
  - 리버스 프락시로 불림
  - 네트워크 가장 끝에 있는 웹 서버들의 바로 앞에 위치
  - 웹 서버로 향하는 모든 요청을 처리
  - 필요할 때 웹 서버에게 자원을 요청
  - 웹 서버에 보안 기능 추가, 웹 서버 캐시 등 개선 가능
  - 일반적으로 웹 서버의 이름과 IP 주소로 스스로를 가장
- 네트워크 교환 프락시
  - 인터링 피어링 교환 지점들에 놓임
  - 인터넷 교차로의 혼잡 완화, 트래픽 흐름 감시

### 6.3.2 프락시 계층

- 원 서버에 도착할 때까지 연쇄로 프락시와 프락시를 거쳐 이동
- 프락시 서버들은 부모와 자식 관계
  - 다음번 인바운드 프락시(서버에 가까운)가 부모
  - 다음번 아웃바운드 프락시(클라이언트에 가까운)가 자식
- 프락시 계층 콘텐츠 라우팅
  - 프락시 계층은 반드시 정적이 아님
  - 여러 가지 판단 근거(가까운 캐시, 요청에 특화된 프락시 등)로 유동적
  - 부하 균형 : 현재 부모들의 작업량 수준에 근거하여 자식 프락시가 부모 프락시를 선택
  - 지리적 인접성에 근거한 라우팅 : 원 서버의 지역을 담당하는 부모를 자식 프락시가 선택
  - 프로토콜/타입 라우팅 : URI에 근거하여 다른 부모나 원 서버로 라우팅 가능 or 특별한 프락시 서버로 보내져서 특별한 프로토콜로 처리될 수도 있음
  - 유료 서비스 가입자를 위한 라우팅 : 추가금을 받고 대형 캐시나 성능 개선을 위한 압축 엔진으로 라우팅 가능
  - 동적 부모 라우팅 로직은 제품 마다 다르게 구현

### 6.3.3 어떻게 프락시가 트래픽을 처리하는가

- 어떻게 프락시로 향하는 길을 찾아내는지(클라이언트 트래픽이 프락시로 가도록 만드는 방법) 알아야 함
- 클라이언트를 수정한다
  - 많은 웹 클라이언트들이 수동 혹은 자동 프락시 설정을 지원
  - HTTP 요청을 바로 원 서버가 아닌 프락시로 보냄
- 네트워크를 수정한다
  - 네트워크 인프라를 가로채서 웹 트래픽을 프락시로 가도록 조정
  - HTTP 트래픽을 지켜본 뒤 가로채고 클라이언트는 알지도 못하고 간섭도 불가능
  - 트래픽을 프락시로 보내는 스위칭 장치와 라우팅 장치를 필요로 함
  - 인터셉트 프락시(투명 프락시)로 불림
- DNS 이름 공간을 수정한다
  - 웹 서버 앞의 대리 프락시가 웹 서버의 이름과 IP 주소를 자신이 직접 사용
  - 모든 요청이 대리 프락시로 감
  - DNS 이름 테이블 수동 편집 & 적절한 프락시나 서버를 계산해 주는 동작 DNS 서버를 이용해서 조정
- 웹 서버를 수정한다
  - HTTP 리다이렉션 명령(305)을 클라이언트에게 돌려줌
  - 요청을 프락시로 리다이렉트

## 6.4 클라이언트 프락시 설정

- 수동 설정
  - 프락시를 사용하겠다고 명시적으로 설정
- 브라우저 기본 설정
  - 브라우저 밴더나 배포자가 브라우저 전달 전 미리 설정
- 프락시 자동 설정(Proxy auto-configuration, PAC)
  - 자바스크립트 프락시 자동 설정(PAC) 파일에 대한 URI를 제공
  - 그 자바스크립트 파일을 실행하여 프락시에 대한 사용 판단
- WPAD 프락시 발견
  - 대부분의 브라우저가 제공
  - 웹 프락시 자동 발견 프로토콜(Web Proxy Autodiscovery Protocol, WPAD)은 자동설정 파일을 다운로드할 수 있는 '설정 서버'를 자동으로 찾아줌

### 6.4.1 클라이언트 프락시 설정: 수동

- 많은 웹 클라이언트가 지원
- 브라우저들마다 방법은 다르지만 동일한 아이디어로 제공
  - 프락시의 호스트와 포트를 지정
- 몇몇 ISP는 그들의 요구에 맞춰진 프락시 서버로 리다이렉트 하는 맞춤형 운영체제 구입

### 6.4.2 클라이언트 프락시 설정: PAC 파일

- 수동 설정이 해결할 수 없는 문제에 대한 동적인 해결책
  - 그때그때 상황(문서에 접근할 때마다)에 맞게 계산해주는 작은 자바스크립트 프로그램
- PAC 파일의 URI를 브라우저에 설정해야 함
  - .pac 확장자를 가짐
  - MIME 타입은 'application/x-ns-proxy-autoconfig'
- 각 PAC 파일은 FindProxyForUrl(url, host) 함수를 정의
  - URI에 접근할 때 사용할 적절한 프락시 서버를 계산
  - 프락시 없는 직접적인 연결, 지정한 프락시 사용, 지정한 SOCKS 서버를 사용하는 함수들이 반환값

### 6.4.3 클라이언트 프락시 설정: WPAD

- 브라우저 설정을 위한 또 다른 메커니즘
- 여러 발견 메커니즘들의 상승 전략을 이용해 알맞은 PAC 파일을 자동으로 찾아주는 알고리즘
- WPAD 프로토콜이 구현된 클라이언트가 할 일
  - WPAD를 사용
  - 주어진 URI에서 PAC 파일 가져옴
  - PAC 파일 실행
  - 알아낸 프락시 서버를 이용해서 요청 처리
- WPAD는 성공할 때까지 각 기법을 다음의 순서로 하나씩 시도
  - 동적 호스트 발견 규약(DHCP)
  - 서비스 위치 규약(SLP)
  - DNS 잘 알려준 호스트 명
  - DNS SRV 레코드
  - DNS TXT 레코드 안의 서비스 URI

## 6.5 프락시 요청의 미묘한 특징들

- 프락시 서버 요청의 미묘하고도 오해하기 쉬운 측면들

### 6.5.1 프락시 URI는 서버 URI와 다르다

- 웹 서버와 웹 프락시 메시지의 문법은 서로 같다.
- 클라이언트가 프락시 대신 서버로 요청을 보내면 요청의 URI가 달라짐
  - 프락시로 요청을 보낼 땐 완전한 URI를 보냄
  - 프락시는 스킴과 호스트를 아는 원 서버와 다르게 목적지 서버와 커넥션을 맺어야 하고 스킴과 연결해야 하므로 완전한 URI가 필요
- 클라이언트가 요청을 보내는 방식
  - 프락시가 사용하지 않도록 설정한 경우 -> 부분 URI
  - 프락시를 사용하도록 설정한 경우 -> 완전 URI

### 6.5.2 가상 호스팅에서 일어나는 같은 문제

- 가상으로 호스팅 되는 웹 서버도 프락시와 마찬가지로 스킴/호스트/포트 번호가 누락되면 문제 발생
- 가상으로 호스팅 되는 웹 서버는 여러 웹 사이트가 같은 물리적 웹 서버를 공유
- 가상으로 호스팅 되는 웹 서버는 호스트와 포트에 대한 정보가 담겨 있는 Host 헤더를 요구함으로써 문제 해결

### 6.5.3 인터셉트 프락시는 부분 URI를 받는다

- 대리 프락시나 인터셉트 프락시로 트래픽이 지날 경우 클라이언트는 자신이 프락시와 대화하고 있다는 것을 모른 채 완전한 URI를 보내지 않음
  - 대리 프락시는 원 서버의 호스트 명과 아이피 주소를 사용하는 프락시 서버
  - 인터셉트 프락시는 클라이언트에서 서버로 가는 트래픽을 가로채 웹 서버로 보내는 부분 URI를 얻음

### 6.5.4 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다

- 프락시로 리다이렉트 될 수 있는 여러 가지 방법이 존재하므로 다목적 프락시는 완전한 URI, 부분 URI를 모두 지원해야 함
- 완전한 URI가 주어지면 프락시는 그것을 사용
- 부분 URI가 주어지고 Host 헤더가 있다면 Host 헤더를 이용해 원 서버의 이름과 포트 번호를 알아내야 함
- 부분 URI가 주어졌으나 Host 헤더가 없을 시
  - 대리 프락시의 경우 프락시에 실제 서버 주소와 포트 번호가 설정되어 있음
  - 이전에 어떤 인터셉트 프락시가 가로챈 트래픽과 원 IP 주소와 포트 번호를 사용할 수 있도록 해두었을 시 사용
  - 모두 실패한 경우 에러 메시지를 반환

### 6.5.5 전송 중 URI 변경

- 프락시 서버는 요청 URI 변경에 매우 신경을 써야 함
- 상호운용성 문제를 일으킬 수 있는 변형을 막기 위해 다음 홉으로 보내기 전 정규화
- 프락시 서버는 가능한 관대하도록 해야 함
- 인터셉트 프락시가 URI를 전달할 때 절대 경로를 고쳐 쓰는 것을 금지

### 6.5.6 URI 클라이언트 자동확장과 호스트 명 분석(Hostname Resolution)

- 브라우저는 프락시에 존재 여부에 따라 요청 URI를 다르게 분석
  - 프락시가 없다면 사용자가 타이핑한 URI를 가지고 그에 대응하는 IP 주소 찾음
- 다음의 방법으로 브라우저들이 짧은 약어로 타이핑된 호스트 명의 '확장'을 제공
  - 가운데 부분 입력했을 시, 'www' 접두사와 '.com' 접미사 붙임
  - 해석할 수 없는 URI를 서드파티 사이트로 넘김 -> 오타 교정 시도 후 사용자가 의도했을 URI 제시
  - 호스트 명의 앞부분만 입력 시 자동으로 도메인 검색하도록 설정

### 6.5.7 프락시 없는 URI 분석(URI Resolution)

- 유효한 호스트 명을 찾는 시도 예제
  - 사용자가 'oreilly'를 URI 창에 입력 시 기본 스킴을 'http://', 기본 포트를 80, 기본 경로를 '/'로 간주
  - 호스트 'oreilly' 찾음 -> 실패
  - 호스트 명을 자동으로 확장 후 DNS에 'www.oreilly.com'의 주소 분해를 요청 -> 성공

### 6.5.8 명시적인 프락시를 사용할 때의 URI 분석

- 브라우저의 URI가 프락시를 그냥 지나쳐버리기 때문에 부분 호스트 명 자동확장 X
  - 사용자가 타이핑 한 그대로 보냄 (기본 스킴과 경로는 추가)
- 몇몇 프락시는 자동확장, 지역 도메인 접미사 추가 등을 최대한 흉내 내려고 시도

### 6.5.9 인터셉트 프락시를 이용한 URI 분석

- 인터셉트 프락시 일 때 호스트명 분석은 DNS 성공 까진 비슷하지만 서버로의 커넥션이 만들어졌을 때는 달라짐
- 클라이언트는 DNS 서버 성공 이후 IP 주소의 목록으로 성공할 때까지 접속을 시도하지만 프락시와 함께일 시 첫 번째 시도 후 시도가 종료된다.
- 프락시는 이때 브라우저와 동등한 수준의 장애 허용 제공을 위해 여러 방법으로 IP 주소를 찾는다.
  - 호스트 헤더에 들어 있는 호스트 명 분석, IP 주소에 대한 역방향 DNS 룩업 등 ...
  - 이러한 시도에서 장애 허용의 여부가 프락시에게 달려 있으므로 프락시가 이를 지원해 주는 것이 중요

## 6.6 메시지 추적

- 오늘날은 웹 요청이 둘 이상의 프락시를 지나가는 일이 흔함
  - 프락시를 넘나드는 메시지의 흐름을 추적하고 문제점을 찾아내는 일이 중요해짐

### 6.6.1 Via 헤더

- Via 헤더 필드는 메시지가 지나는 각 중간 노드의 정보를 나열
- 메시지의 전달 추적, 메시지 루프 진단 등을 알아보기 위해 사용
- 라우팅 루프가 있는지도 탐지
- Via 문법
  - 쉼표로 경유지를 구별
  - 각 경유지는 개별 프락시 서버나 게이트웨이 홉을 나타냄
  - 프로토콜 이름(선택. 기본은 HTTP), 프로토콜 버전(필수), 노드 이름(필수), 코멘트(선택) 최대 4개의 구성요소
  - 프로토콜 이름 : 중개자가 받은 프로토콜, 버전 앞에 "/"로 구분되어 붙음
  - 프로토콜 버전 : 버전의 포맷은 프로토콜에 달려있음
  - 노드 이름 : 호스트와 포트 번호, 가명으로 대체 가능
  - 노드 코멘트 : 벤더나 버전 정보 등을 포함 (선택)
- Via 요청과 응답 경로
  - 요청, 응답 메시지 모두 Via 헤더를 가짐
  - 보통은 응답의 Via 헤더는 요청의 Via 헤더와 반대
- Via와 게이트웨이
  - Via 헤더는 프로토콜 변환을 기록
  - HTTP 애플리케이션은 프락시 연쇄에서 일어난 프로토콜 변환과 능력을 알 수 있음
- Server 헤더와 Via 헤더
  - Server 헤더 필드 : 원 서버에 의해 사용되는 소프트웨어를 명시
  - 프락시는 해당 필드를 수정하면 안 됨, Via 항목을 추가해야 함
- Via가 개인 정보 보호와 보안에 미치는 영향
  - 방화벽 뒤에 숨어있는 호스트 이름과 포트를 전달해서는 안 됨
  - Via 노드 이름 전달이 불가능할 시 호스트 명을 가명으로 교체하지만 Via 경유지 항목을 유지하려 노력해야함
  - 일련의 Via 경유지 유지 항목들을 하나로 합칠 수 있음
  - 경유지들이 모두 같은 조직의 통제 & 호스트가 이미 가명으로 교체되지 않은 이상 항목들을 합치면 안 됨

## 6.6 TRACE 메서드

- 홉에서 홉으로 전달될 때마다 바뀌는 메시지의 내용을 관찰하여 프락시 네트워크를 쉽게 진단하기 위해 사용
- TRACE 요청이 목적지 서버에 도착 시 전체 요청 메시지를 HTTP 응답 메시지의 본문에 포함시켜 돌려보냄
- Max-Forwards
  - TRACE와 OPTIONS 요청의 프락시 홉 개수를 제한하고 싶을 때 사용하는 헤더
  - 무한 루프인지, 프락시 연쇄, 연쇄 중간의 특정 프락시 등을 체크
- 몇 번 더 다음 홉으로 전달될 수 있는지 말해주는 정수 (0일 시 더 이상 전달하지 않고 클라이언트에게 돌려줌)
- 다음 전달될 메시지의 Max-Forwards 필드는 1 감소된 값으로 갱신

## 6.7 프락시 인증

- 유효한 접근 자격을 확인하는 후 없을 시 요청을 차단하는 프락시 인증
  - 프락시 서버가 자격을 요구할 땐 407(Proxy Authorization Required) 상태 코드와 어떻게 자격을 제출해 줄 수 있는지 설명해 주는 Proxy-Authenticate 헤더 필드를 반환
  - 클라이언트는 407 확인 후 로컬 DB나 사용자에게 요구되는 자격 수집
  - 자격 획득 후 Proxy-Authorization 헤더 필드에 담아서 요청 보냄
  - 유효한 자격 일시 요청을 통과, 유효하지 않다면 407 응답
- 인증에 참여하는 프락시가 연쇄상에 여러 개 일시 잘 동작하지는 않음 (일반적으로)

## 6.8 프락시 상호운용성

- 프락시 서버는 여러 벤더에 의해 제각각으로 만들어진 클라이언트와 서버 사이를 중재해야 함

### 6.8.1 지원하지 않는 헤더와 메서드 다루기

- 프락시는 이해할 수 없는 헤더 필드는 반드시 그대로 전달해야 함
  - 동일한 이름의 헤더 필드가 여러 개라면 순서도 반드시 유지

### 6.8.2 OPTIONS: 어떤 기능을 지원하는지 알아보기

- 서버나 웹 서버의 특정 리소스가 어떤 기능을 지원하는지 클라이언트가 알아볼 수 있게 해줌
  - 예를 들면 지원하는 메서드
- 요청 URI가 별표(\*)일 시 서버 전체의 능력에 대한 질문
- 요청 URI가 실제 리소스일 시 특정 리소스에 대한 기능들을 묻는 것
- HTTP/1.1이 명시한 헤더는 Allow 헤더 하나뿐
  - 더 많은 정보를 보내는 것은 허용하지만 정의된 것은 Allow가 유일

### 6.8.3 Allow 헤더

- URI에 의해 식별되는 자원에 대해 지원되는 메서드들이나 서버가 지원하는 모든 메서드를 열거
  - ex) Allow: GET, HEAD, PUT
- 새 리소스가 지원했으면 하는 메서드를 추천하기 위한 요청 헤더로도 사용 가능
  - 서버가 추천받은 메서드를 지원해야 할 의무는 X
- 프락시가 지정된 모든 메서드를 이해할 수 없어도 Allow 헤더 필드를 수정하는 것은 불가능
  - 클라이언트가 다른 경로로 원 서버와 대화할 수도 있기 때문
