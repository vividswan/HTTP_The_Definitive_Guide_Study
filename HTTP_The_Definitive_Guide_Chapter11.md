# 11장 - 클라이언트 식별과 쿠키

- 서버가 통신하는 대상(클라이언트)를 식별하는 데 사용하는 기술

## 11.1 개별 접촉

- HTTP는 익명, 무상태, 요청과 응답으로 통신
  - 무상태란? 연결 자체에 대한 정보 X, 요청은 일회성, 독립적으로 처리
- 현대의 웹 사이트들은 개인화된 서비스를 위해 사용자에 대한 기록을 하고 싶어 함
- 개별 인사
  - 사용자에게 특화된 환영 메시지, 페이지 내용
- 사용자 맞춤 추천
  - 고객이 좋아할 제품을 예상하여 추천
- 저장된 사용자 정보
  - 사용자를 식별 후 저장된 사용자 정보를 사용
- 세션 추적
  - HTTP 트랜잭션은 무상태
  - 웹 사이트는 사용자에게서 오는 HTTP 트랜잭션을 식별할 방법이 필요

## 11.2 HTTP 헤더

- From 헤더는 사용자의 이메일 주소를 포함
  - 악의적으로 사용될 수 있음
- User-Agent 헤더는 사용자가 쓰고 있는 브라우저의 이름과 버전 정보, 운영체제에 대한 정보
  - 특정 사용자 식별엔 큰 도움 X
- Referer 헤더는 사용자가 현재 페이지로 유입하게 한 웹 페이지의 URL
  - 웹 사용자의 사용 행태, 취향 등 파악 가능

## 11.3 클라이언트 IP 주소

- 클라이언트의 IP 주소는 HTTP 표준은 아님
- IP 주소로 식별하는 것의 약점
  - 여러 사용자가 같은 컴퓨터 사용할 시 식별 X
  - 많은 ISP가 동적으로 IP 주소를 할당
  - 네트워크 주소 변환(NAT) 방화벽이 실제 IP 주소를 방화벽 뒤로 숨김
  - 웹 서버는 클라이언트의 IP 주소 대신 프락시 서버의 IP 주소를 봄 (일부 프락시만 해당 문제 해결하려 함)
- 임의로 변경 가능하고 제한된 영역이 아닌 곳에서 동적인 IP 주소는 문제가 발생할 수 있음

## 11.4 사용자 로그인

- 웹 서버는 사용자 이름과 비밀번호로 인증할 것을 요구해서 명시적으로 식별 요청 가능
- HTTP는 로그인이 더 쉽도록 WWW-authenticate와 Authorization 헤더를 사용해 로그인 정보를 보낼 수 있음
- 서버는 HTTP 401 login Required 응답 코드를 통해 접근 전 로그인 시킬 수 있음
  - 사이트에 한 번만 로그인하면 브라우저가 요청마다 Authorization 헤더에 담아 서버로 전송
  - 한 세션이 진행되는 내내 식별 유지

## 11.5 뚱뚱한 URL

- 어떤 웹 사이트는 URL마다 버전을 기술하여 사용자를 식별 & 추적
  - URL 경로의 처음이나 끝에 상태 정보를 추가해 확장
- 사용자의 상태 정보를 포함하고 있는 URL을 뚱뚱한 URL이라고 함
  - 독립적인 HTTP 트랜잭션을 하나의 세션이나 방문으로 묶는 용도로 사용
  - 유일한 ID를 URL에 추가하여 서버는 클라이언트를 뚱뚱한 URL로 리다이렉트
- 뚱뚱한 URL의 문제
  - 못생긴 URL : 사용자에게 혼란을 줌
  - 공유하지 못하는 URL : 주소에 누적된 개인 정보가 포함
  - 캐시를 사용할 수 없음 : URL이 달라지기 때문에 기존 캐시에 접근할 수 없음
  - 서버 부하 가중 : 서버는 뚱뚱한 URL의 HTML 페이지를 다시 그려야 함
  - 이탈 : 특정 URL에 의해 의도치 않게 URL 세션을 이탈하기 쉬움
  - 세션 간 지속성의 부재 : 로그아웃 시 모든 정보를 잃음

## 11.6 쿠키

- 현재 가장 널리 사용하는 방식
- 모든 브라우저에서 지원
- 캐시와 충돌 가능하므로 대부분의 캐시나 브라우저는 쿠키 내용물을 캐싱 X

### 11.6.1 쿠키의 타입

- 세션 쿠키, 지속 쿠키로 나눠짐
- 세션 쿠키는 탐색 시 정보를 저장하는 임시 쿠키
  - 브라우저를 닫으면 삭제
- 지속 쿠키는 삭제되지 않고 더 길게 유지 가능
  - 디스크에 저장
  - 브라우저를 닫거나 컴퓨터를 재시작하더라도 남아 있음
  - 방문 사이트 설정 정보, 로그인 이름 등을 유지
- 세션 쿠키와 지속 쿠키의 다른 점은 파기되는 시점뿐

### 11.6.2 쿠키는 어떻게 동작하는가

- 쿠키는 사용자에게 서버가 붙여주는 스티커와 같음
  - 사용자가 다시 돌아왔을 때 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당
- 이름=값 형태의 리스트
- Set-Cookie, Set-Cookie2와 같은 HTTP 응답 헤더에 기술
- 많은 웹 서버가 정보를 쿠키에 유지

### 11.6.3 쿠키 상자: 클라이언트 측 상태

- `HTTP 상태 관리 체계 (HTTP State Management Mechanism)`
  - 브라우저가 쿠키 정보를 저장할 책임
- 브라우저는 서버가 전송한 쿠키를 저장하고 그 서버에 접근할 때마다 함께 전송
- 구글 크롬 쿠키
  - Cookies라는 SQLite 파일에 쿠키를 저장
  - 13개의 필드 존재
- 마이크로소프트 인터넷 익스플로러 쿠키
  - 캐시 디렉터리에 각각의 개별 파일로 쿠키를 저장
  - 쿠키의 이름, 쿠키의 값, 도메인과 경로, 추가적으로 들어갈 정보들로 구성

### 11.6.4 사이트마다 각기 다른 쿠키들

- 브라우저는 각 사이트에 두 대 혹은 세 개의 쿠키만을 보냄
  - 쿠키를 모두 전달하면 성능이 크게 저하
  - 대부분 각자 서버에 특화된 이름/값 쌍 -> 다른 서버에선 무의미
  - 잠재적인 개인 정보 문제 발생 가능
- 보통 쿠키를 생성한 서버에게만 쿠키의 정보 전달
  - 광고사는 같은 도메인의 광고를 서로 다른 웹 사이트에 보내서 Referer 헤더와 쿠키로 방대한 데이터 구축 가능
- 쿠키 Domain 속성
  - 쿠키 생성 시 Set-Cookie 응답 헤더에 Domain 속성을 기술하여 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어 가능
- 쿠키 Path 속성
  - URL 경로의 앞부분을 가리키는 Path 속성으로 웹 사이트 일부에만 쿠키를 적용 가능
  - 생성 시 "path=/autos/" 와 같이 적용

### 11.6.5 쿠키 구성요소

- 넷스케이프 쿠키라고 불리는 Version 0 쿠키 명세가 널리 쓰임
  - Version 1 쿠키는 이의 확장으로 널리 쓰이지는 않음
- 둘 모두 HTTP/1.1 명세 일부로 기술되어 있지는 않음

### 11.6.6 Version 0(넷스케이프) 쿠키

- Set-Cookie 응답 헤더와 Cookie 요청 헤더, 쿠키를 조작하는 데 필요한 필드들 정의
- Version 0 Set-Cookie 헤더
  - 쿠키의 이름과 값을 가져야 함
  - 세미콜론으로 이어 기술
  - 이름=값 : 필수 속성이며 세미콜론, 쉼표, 등호, 공백을 포함하지 않는 문자열
  - Expires : 선택적인 속성, 쿠키의 생명주기를 가리키는 날짜 문자열을 기술, GMT 타임 존 사용
  - Domain : 선택적 속성, 이 속성에 기술된 도메인을 사용하는 서버 호스트 명으로만 쿠키 전송, 적어도 세 개의 도메인 영역 기술
  - Path : 선택적 속성, 서버에 있는 특정 문서에만 쿠키 전송, 앞부분과 일치 시 전달
  - Secure : 선택적 속성, HTTP가 SSL 보안 연결을 사용할 때만 쿠키 전송
- Version 0 Cookie 헤더
  - 모든 쿠키는 Cookie 헤더에 한데 이어 붙여 보냄
  - Domain, Path, Secure 필터들의 조건을 만족해야 함

### 11.6.7 Version 1 (RFC 2965) 쿠키

- Set-Cookie2와 Cookie2 헤더를 소개
- Version 0 시스템과도 호환
- 모든 브라우저나 서버에선 완전 지원 X
- 추가된 주요 변경 사항
  - 쿠키의 목적 설명문
  - 브라우저가 닫히면 강제로 쿠키 삭제 가능
  - 상대 값으로 생명주기를 관리하는 Max-Age
  - URL의 포트 번호로도 제어 가능
  - 도메인, 포트, 경로 필터가 있으면 Cookie 헤더에 담겨 되돌려 보냄
  - 호환되는 버전 번호
  - Cookie 헤더에 $ 접두어 (사용자 이름과 추가적인 키워드 구별)
- Version 1 Set-Cookie2 헤더
  - 넷스케이프 표준보다 더 많은 속성이 있음
  - Version : 버전 명시
  - Comment : 쿠키 설명
  - CommentURL : 쿠키 정책에 대해 기술된 웹 페이지
  - Discard : 클라이언트 프로그램 종료 시 쿠키 삭제
  - Max-Age : 쿠키의 생명주기를 초 단위로 산정
  - Port : 쿠키가 적용될 포트를 구분하여 기술
- Version 1 Cookie 헤더
  - 해당 쿠키의 필터 중 현재 사이트에 맞는 필터를 기술
  - Set-Cookie2 필터 중 현재의 웹 사이트에 들어맞는 필터 정보에 달러 문자($)를 붙여서 쿠키와 함께 전송
- Version 1 Cookie2 헤더와 버전 협상
  - 다른 버전을 지원하는 클라이언트와 서버 간에 호환성을 협상하는 용도로 사용
  - 해당 쿠키 표준의 버전 정보를 서버에 제공
  - 서버가 새로운 형식의 쿠키를 인식한다면 Set-Cookie 응답 헤더를 보냄
  - 인식 못 할 시 Version 0의 Set-Cookie 헤더 전송
  - 클라이언트는 서버의 응답에 따라 쿠키를 보냄

### 11.6.8 쿠키와 세션 추적

- 쿠키는 트랜잭션을 만들어내는 사용자를 추적하는 데 사용
- 리다이렉트, URL 리라이트, 쿠키 설정을 통해 서버가 식별 정보를 첨부하기 위한 연속적인 트랜잭션 시작

### 11.6.9 쿠키와 캐싱

- 쿠키 트랜잭션과 관련된 문서를 캐싱 하는 것은 주의를 요함
  - 개인 정보 노출 가능
- 캐시 되지 말아야 할 문서가 있다면 표시하라
  - Cookie 헤더를 제외하고 캐시를 해도 될 경우엔 `Cache-Control: no-cache="Set-Cookie"`를 기술
  - 캐시를 해도 되는 문서는 `Cache-Control: public`
- Set-Cookie 헤더를 캐시 하는 것에 유의하라
  - 같은 Set-Cookie 헤더를 여러 사용자에게 보내게 되면 사용자 추적에 실패할 것
  - Set-Cookie 헤더가 제거된 쿠키 또한 클라이언트가 Cookie 관련 정보가 없는 데이터를 받게 되어 문제 발생 가능
  - 캐시가 모든 요청마다 원 서버와 재검사 후 클라이언트로 가는 응답에 Set-Cookie 헤더 값을 기술해서 문제 해결 가능 (must-revalidate)
  - 보수적으로 Set-Cookie 헤더를 가지고 있는 응답은 캐시 하지 않는 방법도 있음
- Cookie 헤더를 가지고 있는 요청을 주의하라
  - 요청이 Cookie 헤더와 함께 온다는 것 -> 결과 콘텐츠가 개인 정보를 담고 있을 수 있다는 힌트

### 11.6.10 쿠키, 보안 그리고 개인 정보

- 원격 데이터베이스에 개인 정보 저장 후 데이터의 키값을 쿠키에 저장하는 방식으로 예민한 데이터를 보호할 수 있음
- 쿠키를 이용해 개인 정보와 사용자 추적 기술은 오용할 수 있으므로 주의
- 개인 정보를 받는 쪽을 확실히 하고 사이트의 개인 정보 정책에 유의한다면 위험성보단 편리함이 더 커짐
