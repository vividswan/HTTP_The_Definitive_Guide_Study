# 14장 - 보안 HTTP

- 디지털 암호화를 이용해 도청이나 위조로부터 HTTP 트랜잭션을 안전하게 보호하는 기술

## 14.1 HTTP를 안전하게 만들기

- 웹은 안전한 방식의 HTTP를 필요로 함
- HTTP와 디지털 암호화 기술을 결합해서 중요한 트랜잭션 보안
- 다음이 요구됨
  - 서버 인증 : 클라이언트에게 진짜 서버와 이야기하고 있음을 보장
  - 클라이언트 인증 : 서버는 진짜 사용자와 이야기하고 있음을 보장
  - 무결성 : 데이터가 위조되는 것으로부터 안전해야 함
  - 암호화 : 도청에 대한 걱정이 없이 대화할 수 있어야 함
  - 효율 : 충분히 빠른 알고리즘
  - 편재성 : 거의 모든 클라이언트와 서버에게 지원
  - 관리상 확장성 : 누구든, 어디서든 즉각적인 보안 통신
  - 적응성: 현재 알려진 최선의 보안 방법
  - 사회적 생존성 : 사회의 문화적, 정치적 요구를 만족시켜야 함

### 14.1.1 HTTPS

- HTTP를 안전하게 만드는 방식 중에서 가장 인기 있는 것
  - 넷스케이프 커뮤니케이션 주식회사에서 개척
  - 모든 주류 브라우저와 서버에서 지원
- URL이 "http://" 대신 "https://" 로 시작
- 모든 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화
- HTTP 하부에 전송 레벨 암호 보안 계층 제공
  - `안전 소켓 계층(Secure Sockets Layer, SSL)` 혹은 `전송 계층 보안(Transport Layer Security, TLS)`을 이용하여 구현
  - 둘은 매우 비슷함
- 인코딩 및 디코딩 작업이 SSL 라이브러리 안에서 일어남
- TCP 입력/출력 호출을 SSL 호출로 대체

## 14.2 디지털 암호학

- 디지털 암호의 기초
  - 암호 : 인코딩하는 알고리즘
  - 키 : 암호의 동작을 변경하는 숫자로 된 매개변수
  - 대칭키 암호 체계 : 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
  - 비대칭키 암호 체계 : 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
  - 공개키 암호법 : 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
  - 디지털 서명 : 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
  - 디지털 인증서 : 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

### 14.2.1 비밀 코드의 기술과 과학

- 암호법 : 메시지 인코딩과 디코딩에 대한 과학이자 기술
- 메시지 암호화 뿐 아니라 메시지 변조를 방지하기 위해 사용
  - 누군가가 정말로 어떤 메시지나 트랜잭션의 저자임을 증명하는 데도 사용

### 14.2.2 암호(cipher)

- 암호법은 암호라 불리는 비밀 코드에 기반
  - 인코딩, 디코딩 하는 방법
- 평문 : 인코딩되기 전의 원본 메시지
  - 텍스트라고도 불림

### 14.2.3 암호 기계

- 기술의 진보와 함께 복잡한 암호로 빠르게 인코딩 디코딩 하는 기계를 개발

### 14.2.4 키가 있는 암호

- 기계를 훔쳐 가도 올바른 키값 없이는 디코더가 동작 X
- 암호 키는 하나의 암호 기계를 여러 가상 암호 기계의 집합처럼 만들어줌
  - 다른 키를 사용하여 N번 회전

### 14.2.5 디지털 암호

- 디지털 계산의 도래
  - 복잡한 인코딩과 디코딩 알고리즘이 가능해짐
  - 매우 큰 키를 지원하는 것이 가능해짐 (키가 길수록 인코딩 조합이 많아지고 크래킹이 어려워짐)
- 디지털 키는 숫자 (인코딩과 디코딩 알고리즘에 대한 입력값)
- C = E(P,e)
  - 평문 메시지 P
  - 인코딩 함수 E
  - 디지털 인코딩 키 e
  - 인코딩과 디코딩은 서로의 역

## 14.3 대칭키 암호법

- 대칭키 암호
  - 인코딩 할 때 사용하는 키가 디코딩을 할 때와 같음
- 발송자와 수신자 모두 비밀 키 k를 똑같이 공유
  - 같은 키로 암호화와 해독 함수를 적용
- DES, Triple-DES, RC2, RC4 등이 잘 알려진 대칭키 암호 알고리즘

### 14.3.1 키 길이와 열거 공격(Enumeration Attack)

- 대부분의 알고리즘은 공개적이므로 키만이 유일한 비밀
- 열거 공격 : 무차별적으로 모든 키값을 대입해 보는 공격
  - 가능한 키값이 아주 많다면 시간이 많이 소요됨
- 키가 몇 비트이며 얼마나 많은 키가 유효한지에 따라 가능한 키값의 개수가 달려있음
  - 예를 들어 40비트면 2의 40제곱 -> 약 1조
  - 초당 수십억 번의 계산에선 40비트는 쉽게 깨질 수 있음
- 128비트 키를 사용한 대칭키 암호는 강력한 것으로 간주

### 14.3.2 공유키 발급하기

- 대칭키 암호화의 단점 : 둘 다 공유키를 가져야 함
  - N개의 노드가 있고 각 노드가 상대 N-1 암호로 대화 시 대략 N의 제곱의 비밀 키가 필요

## 14.4 공개키 암호법

- 공개키 암호 방식은 두 개의 비대칭 키를 사용
  - 하나는 호스트의 메시지를 인코딩
  - 다른 하나는 그 호스트의 메시지를 디코딩
  - 인코딩 키는 모드를 위해 공개
  - 호스트만이 개인 디코딩 키를 알고 있음
- 노드 X는 자신의 인코딩 키를 공개적으로 배포
  - X에게 메시지를 보낼 때 누구나 공개키 사용
  - 대칭 키의 쌍이 폭발적으로 증가하는 것을 피함
  - X를 제외한 그 누구도 디코딩 불가능
  - 결국 키의 분리로 인코딩은 누구나 할 수 있고 디코딩은 소유자만 가능해짐

### 14.4.1 RSA

- RSA는 다음을 공격자가 알고 있어도 개인키 계산 불가능
  - 공개키(누구나 얻을 수 있음)
  - 가로채서 얻은 암호문의 일부
  - 메시지와 그것을 암호화한 암호문
- 암호를 크래킹 하여 개인 키를 찾아내는 것은 엄청나게 어렵다.

### 14.4.2 혼성 암호 체계와 세션 키

- 개인 키에 대한 협상이 먼저 필요
- 공개키 암호 방식의 알고리즘은 느린 경향
- 실제로는 대칭과 비대칭 방식을 섞은 것을 사용
  - 안전한 의사소통 채널 수립 시엔 공개 키 암호를 사용
  - 안전한 채널을 통해 임시의 무작위 대칭 키를 생성 후 교환하여 이후의 데이터 암호화는 대칭 키를 사용

## 14.5 디지털 서명

- 암호 체계는 메시지의 암호화와 해독뿐 아니라 누가 메시지를 썼고 메시지의 위변조성을 확인해야 함

### 14.5.1 서명은 암호 체크섬이다

- 디지털 서명은 메시지에 붙어있는 특별한 암호 체크섬
- 두 가지 이점
  - 서명은 메시지를 작성한 저자가 누군지 알려줌 (극비 개인 키로)
  - 서명은 메시지 위조를 방지함 (공격자가 메시지 수정 시 체크섬이 맞지 않으므로)
- 디지털 서명은 보통 비대칭 공개키에 의해 생성
  - 노드 A가 요약을 개인 키를 매개변수로 서명 함수 적용
  - 반대편 노드가 노드 A의 공개키를 이용해 역함수 적용
  - 노드 A가 메시지를 정말로 썼으며 위조되지도 않았다는 것을 확인

## 14.6 디지털 인증서

- 디지털 인증서
  - 흔히 'certs'라고 불림
  - 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있음

### 14.6.1 인증서의 내부

- 공식적으로 인증 기관에 의해 디지털 서명된 정보의 집합이 담겨있음
- 기본적인 디지털 인증서에 담겨있는 것
  - 대상의 이름(사람, 서버, 조직 등)
  - 유효 기간
  - 인증서 발급자 (누가 이 인증서를 보증하는가)
  - 인증서 발급자의 디지털 서명
- 대상과 사용된 서명 알고리즘에 대한 서술적인 정보 & 대상의 공개키도 담고 있음
  - 누구나 인증서를 보증할 만한 서명 권한을 얻을 수 있는 것은 아님

### 14.6.2 X.509 v3 인증서

- 디지털 인증서에 대한 전 세계적인 표준은 없음
- 오늘날 사용되는 대부분 인증서는 X.509라고 불리는 표준화된 서식에 저장
- 파싱 가능한 필드에 넣어 구조화
- 인증서 필드들
  - 버전 : 인증서가 따르는 X.509 인증서 버전의 번호
  - 일련번호 : 인증기관에 의해 생성된 고유한 정수
  - 서명 알고리즘 ID : 사용된 암호 알고리즘
  - 인증서 발급자 : 발급하고 서명한 기관 이름
  - 유효 기간
  - 대상의 이름 : 사람, 조직과 같은 엔터티
  - 대상의 공개 키 정보 : 공개 키, 공개 키에 사용된 알고리즘
  - 발급자의 고유 ID (선택적) : 발급자의 이름이 겹칠 경우 대비
  - 대상의 고유 ID (선택적) : 대상의 이름이 겹치는 경우를 대비
  - 확장 : 선택적인 확장 필드의 집합 (기본 제약, 인증서 정책, 키 사용)
  - 인증기관 서명 : 인증기관의 디지털 서명, 명시된 서명 알고리즘 사용
- X.509 기반 인증서는 웹 서버 인증서, 클라이언트 이메일 인증서, 소프트웨어 코드 사인 인증서 등등이 존재 ..

### 14.6.3 서버 인증을 위해 인증서 사용하기

- 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져옴
  - 서버가 인증서를 갖고 있지 않다면 보안 커넥션 실패
- 서버 인증서는 다음의 필드를 포함
  - 웹 사이트 이름과 호스트 명
  - 웹 사이트의 공개키
  - 서명 기관의 이름
  - 서명 기관의 서명
- 브라우저는 인증서를 받은 후 서명 기관 검사
  - 브라우저들은 여러 서명 기관의 인증서가 미리 설치된 채로 출하
  - 신뢰할 만한 서명 기관이라면 그것의 공개키를 알고 있다.
  - 모르는 기관일 시 서명 기관을 신뢰 확인을 위한 대화 상자 보여줌

## 14.7 HTTPS의 세부 사항

- HTTPS는 HTTP의 가장 유명한 보안 버전
  - 널리 구현 & 상용 브라우저와 서버에 구현
  - HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합

### 14.7.1 HTTPS 개요

- HTTPS는 HTTP를 TCP로 보내기 전에 암호화된 보안 계층으로 보냄
  - 보안 계층은 SSL과 SSL의 현대적 대체품인 TLS

### 14.7.2 HTTPS 스킴

- 보안이 없는 일반적인 HTTP의 URL 스킴 접두사는 http
  - 클라이언트는 서버에 80번 포트로 연결하고 평범한 HTTP 명령 전송
- 보안이 되는 HTTPS 프로토콜에서 URL의 스킴 접두사는 https
  - 클라이언트는 서버에 443번 포트를 연결
  - 서버와 바이너리 포맷으로 된 몇몇 SSL 매개변수를 교환하며 핸드셰이크
- SSL 트래픽은 바이너리 프로토콜

### 14.7.3 보안 전송 셋업

- HTTPS에서 클라이언트는 웹 서버의 443 포트로 연결
- TCP 연결 후 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하며 SSL 계층 초기화
- 핸드셰이크 완료 후 SSL 초기화가 완료되고 클라이언트는 요청 메시지를 보안 계층에 보냄
- 보안 메시지는 TCP로 보내지기 전에 암호화

### 14.7.4 SSL 핸드셰이크

- 암호화된 메시지를 보내기 전 클라이언트와 서버는 SSL 핸드셰이크를 함
- 핸드셰이크에서 일어나는 일들
  - 프로토콜 버전 번호 교환
  - 양쪽이 알고 있는 암호 선택
  - 양쪽의 신원을 인증
  - 채널을 암호화하기 위한 임시 세션 키 생성
- 단순화한 버전의 핸드셰이크
  - 클라이언트가 암호 후보들을 보내고 인증서를 요구
  - 서버는 선택된 암호와 인증서를 보냄
  - 클라이언트가 비밀정보를 보내고 클라이언트와 서버가 키를 만듦
  - 클라이언트와 서버는 서로에게 암호화를 시작한다고 말해줌

### 14.7.5 서버 인증서

- 오늘날 클라이언트 인증서는 웹 브라우저에선 흔히 쓰이지 않음
- 보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구
  - 누군가가 웹 서버에 정보를 보낼 때 정확히 보냈는지 알고 싶어 함
  - 잘 알려진 인증기관에 의해 서명된 서버 인증서는 신뢰 평가를 도와줌
- 서버 인증서는 조직의 이름, 주소 서버 DNS 도메인 이름, 그 외의 정보를 보여주는 인증서
  - X.509 v3에서 파생
- 사용자와 사용자의 클라이언트는 인증서로 믿을 만한 것 인지 검증

### 14.7.6 사이트 인증서 검사

- 최신 웹브라우저들 대부분은 인증서에 대해 간단한 기본 검사와 철저한 검사 방법을 알려줌
- 넷스케이프가 제안한 웹 서버 인증서 검사의 알고리즘 단계
  - 날짜 검사 : 인증서의 유효함 확인
  - 서명자 신뢰도 검사 : 브라우저가 서명에 대해 신뢰할 만한 서명 기관으로부터 받은 것인지 검사
  - 서명 검사 : 서명 기관이 믿을 만하다고 판단 후 서명기관의 공개키를 서명에 적용하여 무결성 검사
  - 사이트 신원 검사 : 인증서의 도메인 이름이 대화 중인 서버의 도메인 이름과 비교하여 맞는지 검사

### 14.7.7 가상 호스팅과 인증서

- 가상 호스트로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운 경우가 많음
- 하나의 인증서 만을 지원하는 것을 해결하기 위해 소유자는 보안 트랜잭션을 시작하는 모든 사용자를 하나의 주소로 리다이렉트함

## 14.8 진짜 HTTPS 클라이언트

- SSL은 복잡한 바이너리 프로토콜
  - 가공되지 않은 SSL 트래픽을 직접 보내면 안 됨

### 14.8.1 OpenSSL

- SSL과 TLS의 가장 인기 있는 오픈 소스 구현
- SSLeay 라이브러리를 계승
- 강력한 다목적 암호법 라이브러리
- SSL과 TLS 프로토콜을 구현한 강건하고 완전한 기능을 갖춘 상용 수준의 툴킷

### 14.8.2 우리의 단순한 Open SSL 클라이언트 실행하기

- HTTPS 접속 과정
  - SSL 컨텍스트 초기화
  - TCP 커넥션 생성
  - SSL 종단 생성 후 핸드셰이크
  - SSL 암호로 연결
  - 서버 인증서 획득
  - 암호화된 채널을 통해 HTTP 요청
  - HTTP 응답을 가져옴
  - 커넥션을 닫고 정리
- 한번 SSL 채널 수립 후 클라이언트는 자신의 HTTP 요청을 보안 채널을 통해 전송

## 14.9 프락시를 통한 보안 트래픽 터널링

- 클라이언트는 자신을 대신하여 웹 서버에 접근해 주는 웹 프락시 서버를 종종 이용
  - 회사의 기업 네트워크와 공공 인터넷을 잇는 경계에 보안을 위해 사용
- 프락시는 암호화된 요청을 다룰 수 없음
  - HTTPS SSL 터널링 프로토콜을 사용해야 함
- HTTPS SSL 터널링 프로토콜
  - 클라이언트는 프락시에게 연결하고자 하는 호스트와 포트를 평문으로 말해줌
  - HTTP CONNECT 메서드는 프락시에게 희망하는 호스트와 포트 번호로 연결을 해달라고 말해줌
  - 클라이언트와 서버 사이에서 데이터가 오갈 수 있는 터널을 만듦
  - 커넥션을 위한 핸드셰이크 성공 후 SSL 데이터 전송이 시작
- CONNET 명령어의 HTTP 요청 헤더줄과 빈 줄 이후 SSL 데이터 전송이 시작
- 프락시는 요청 확인 후 적법하다면 200 Connection Established 응답을 클라이언트에게 보냄
