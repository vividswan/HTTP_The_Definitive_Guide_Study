# 7장 - 캐시

- 캐시의 혜택
  - 네트워크 요금 비용 감소
  - 네트워크 병목 감소
  - 원 서버에 대한 요청 감소
  - 거리로 인한 지연 감소

## 7.1 불필요한 데이터 전송

- 복수의 클라이언트가 원 서버에 접근할 때 원 서버는 같은 문서를 전송함
- 캐시를 이용해 첫 번째 서버 응답을 보관 후 뒤이은 요청에 대한 응답으로 사용
- 트래픽을 주고받는 낭비 감소

## 7.2 대역폭 병목

- 네트워크는 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공
- 클라이언트가 LAN에 있는 캐시로부터 사본을 가져올 시 성능 대폭 개선 가능
  - 대역폭은 큰 문서에 대해 현저한 지연을 일으킴

## 7.3 갑작스러운 요청 쇄도(Flash Crowds)

- 갑작스럽게 많은 사람들이 거의 동시에 웹 문서를 접근할 때 캐시로 대처하는 것이 중요

## 7.4 거리로 인한 지연

- 거리 역시 문제가 될 수 있음
  - 빛의 속도 자체가 유의미한 지연 유발
- 기계실 근처에 캐시를 설치 후 문서 전송 거리를 수천 킬로미터에서 수십 미터로 줄일 수 있음

## 7.5 적중과 부적중

- 캐시가 세상 모든 문서의 사본을 저장하지는 않음
  - 캐시로 대응하는 사본이 있을 시 캐시 적중
  - 대응하는 사본이 없을 시 캐시 부적 중 (원 서버로 전달)

### 7.5.1 재검사(Revalidation)

- 재검사 : 캐시가 갖고 있는 사본이 여전히 최신인지 점검
  - 신선도 검사
  - HTTP 서버로부터 전체 객체를 가져오지 않고도 빠르게 검사하는 특별한 요청 정의
- 대부분 클라이언트가 사본을 요청 시 그 사본이 검사를 할 필요가 있을 정도로 오래된 경우 재검사
- 재검사 필요시 원 서버에 재검사 요청 보냄
  - 콘텐츠가 변경되지 않았을 시 서버는 304 Not Modified 응답
  - 응답 후 캐시는 사본이 신선하다고 표시 뒤 클라이언트에게 제공 (재검사 적중, 느린 적중이라 불림)
  - 재검사 적중은 캐시 적중보단 느리고 캐시 부적중보단 빠름
- If-Modified-Since 헤더
  - 서버에게 보내는 GET 요청에 추가된다면 캐시 된 시간 이후에 변경된 경우에만 사본을 보냄
  - 재검사 적중 : 서버가 304 Not Modified를 보냄 (여전히 신선)
  - 재검사 부적중 : 서버는 콘텐츠 전체와 HTTP 200 OK를 클라이언트에게 제공
  - 객체 삭제 : 서버 객체가 삭제되었을 시 서버는 404 Not Found 응답을 보내고 캐시는 사본을 삭제

### 7.5.2 적중률

- 캐시가 요청을 처리하는 비율
- 캐시 적중률(캐시 적중비), 문서 적중률(문서 적중비)로 부름
- 흔히 퍼센트로 부름
- 적중률은 예측하기 어렵지만 40%면 웹 캐시로 괜찮은 편

### 7.5.3 바이트 적중률

- 몇몇 큰 객체는 덜 접근되지만 그 크기 때문에 전체 트래픽에는 더 크게 기여
- 바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율 표현
- 바이트 단위 적중률의 개선은 대역폭 절약을 최적화

### 7.5.4 적중과 부적중의 구별

- HTTP는 클라이언트에게 응답이 캐시 적중이었는지 원 서버 접근인지 말해줄 수 없음
  - Via 헤더에 추가 정보를 붙이는 사용 프락시 캐시가 있기는 함
- Date 헤더를 이용해 응답의 생성일이 더 오래됐다면 응답이 캐시 된 것으로 판단 가능
- 응답이 얼마나 오래되었는지 말해주는 Age 헤더를 이용할 수도 있음

## 7.6 캐시 토폴로지

- 전용 캐시
  - 한 명에게만 할당된 캐시
  - 한 명의 사용자가 자주 찾는 페이지를 담음
- 공용 캐시
  - 공유된 캐시
  - 사용자 집단에게 자주 쓰이는 페이지를 담음

### 7.6.1 개인 전용 캐시

- 작고 저렴할 수 있음
- 웹브라우저는 개인 전용 캐시 내장
  - 개인 컴퓨터의 디스크와 메모리
  - 사용자가 확인 가능

### 7.6.2 공용 프락시 캐시

- 캐시 프락시 서버, 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버
  - 로컬 캐시에서 문서 제공, 사용자의 입장에서 서버에 접근
- 개인 전용 캐시보다 트래픽을 줄일 수 있는 많은 기회
- 수동 프락시를 지정 혹은 프락시 자동 설정 파일을 설정
  - 브라우저가 프락시 캐시를 사용
  - 인터셉트 프락시 사용도 가능

### 7.6.3 프락시 캐시 계층들

- 보통 더 큰 부모 캐시가 작은 자식 캐시의 부적증을 걸러내도록 설계하는 것이 합리적
  - 부모 캐시는 관심사가 제각각인 자식 캐시들의 트래픽을 감당해야 하므로 더 고성능

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

- 복잡한 캐시망의 프락시 캐시는 캐시 커뮤니케이션 결정을 동적으로 내림
- 콘텐츠 라우팅을 위해 설계된 캐시들이 하는 일
  - URL에 근거, 부모 캐시와 원 서버 중 하나를 동적으로 선택
  - URL에 근거, 특정 부모 캐시를 동적으로 선택
  - 부모 캐시에게 가기 전 사본을 로컬에서 찾아봄
  - 다른 캐시들이 그들의 캐시 된 콘텐츠에 부분적으로 접근할 수 있도록 허용, 캐시를 통한 트랜짓은 허용 X
- 선택적인 피어링을 지원하는 캐시는 형제 캐시라고 불림
  - HTTP는 지원 X
  - 캐시 프로토콜(ICP), 하이퍼텍스트 캐시 프로토콜(HTCP)와 같은 프로토콜을 이용해 HTTP 확장

## 7.7 캐시 처리 단계

- 사용 프락시 캐시는 복잡
  - 고성능 & HTTP 외 다른 기술의 고급 기능 지원
- 다음의 일곱 단계로 구성
  - 요청받기, 파싱, 검색, 신선도 검사, 응답 생성, 발송, 로깅(선택적)

### 7.7.1 단계 1: 요청받기

- 캐시는 네트워크 커넥션에서의 활동 감지
- 들어오는 데이터 읽어드림
- 여러 개의 들어오는 커넥션들로부터 데이터를 동시에 읽어드리고 메시지 전체가 도착하기 전 트랜잭션 처리 시작

### 7.7.2 단계 2: 파싱

- 요청 메시지를 여러 부분으로 파싱
  - 헤더 부분을 조작하기 쉬운 자료 구조에 담음
  - 헤더 필드를 처리하고 조작하기 쉽게 만들어줌

### 7.7.3 단계 3: 검색

- URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사
- 수준 높은 캐시는 로컬 캐시에서 가져올 수 있는지 판단 알고리즘 사용
  - 로컬에 없을 시 원 서버나 부모 서버에서 가져오거나 실패 반환
- 개시된 객체는 서버 응답 본문, 원 서버 응답 헤더, 메타데이터 포함

### 7.7.4 단계 4: 신선도 검사

- 오래 갖고 있었던 캐시는 '신선하지 않은' 것으로 간주
  - 문서를 제공 전 변경 검사를 위해 서버와 재검사
- 신선도 검사 규칙은 매우 복잡

### 7.7.5 단계 5: 응답 생성

- 캐시 된 서버 응답 헤더를 토대로 응답 헤더 생성
- 캐시가 클라이언트에 맞게 응답 헤더를 적절히 조정해야 하는 책임을 가짐
- 캐시 신선도 정보도 삽입 (Cache-Control, Age, Expires 헤더)
- 종종 Via 헤더도 포함
- 캐시가 Date 헤더를 조정해서는 안 됨
  - Date 헤더는 그 객체가 원 서버에서 최초로 생겨난 일시

### 7.7.6 단계 6: 전송

- 응답 헤더 준비 후 응답을 클라이언트에게 돌려줌
- 프락시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있음
  - 로컬 저장 장치, 네트워크 I/O 버퍼 사이에서 문서의 콘텐츠 복사를 피함 -> 데이터를 효과적으로 전송

### 7.7.7 단계 7: 로깅

- 대부분의 캐시는 로그 파일과 캐시 사용에 대한 통계 유지
  - 통계 캐시 적중과 부적중 횟수 통계 갱신
  - 로그 파일에 요청 종류, URL, 일어난 일을 항목에 추가
- 스퀴드 로그 포맷, 넷스케이프 확장 공용 로그 포맷, 커스텀 로그 파일 등 허용

## 7.8 사본을 신선하게 유지하기

- 오래된 데이터를 제공하는 캐시는 불필요
- 문서 만료와 서버 재검사
  - 캐시 된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 메커니즘

### 7.8.1 문서 만료

- HTTP는 Cache-Control과 Expires 헤더들을 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해줌
  - ex) Cache-Control : max-age=484200
  - ex) Expires : Fri, 05 Jul 2002, 05:00:00 GMT
- 캐시 문서 만료 전 캐시는 사본 제공 가능

### 7.8.2 유효기간과 나이

- HTTP/1.1 Cache-Control: max-age와 HTTP/1.0+ Expires 헤더는 기본적으로 같은 일
- Cache-Control: max-age
  - max-age 값은 문서의 최대 나이 정의, 합법적인 최댓값, 초 단위
  - Expires는 절대 유효기간을 명시

### 7.8.3 서버 재검사

- 캐시 된 문서가 만료되었다는 것은 원 서버의 자료와 다르다는 것이 아닌 검사할 시간이 되었다는 뜻
- 원 서버에게 캐시가 문서 변경 여부를 물어볼 필요가 있음을 의미하는 '서버 재검사'
  - 재검사 결과 콘텐츠가 변경 : 캐시는 그 문서의 새로운 사본을 가져움
  - 재검사 결과 콘텐츠가 변경 X : 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 갱신
- HTTP 프로토콜이 요구하는 캐시의 적절한 행동
  - '충분히 신선한' 캐시 된 사본
  - 원 서버와 재검사 된 충분히 신선하다고 확신되는 사본
  - 에러 메시지(원 서버 다운의 경우)
  - 경고 메시지가 부착된 사본(부정확할 시)

### 7.8.4 조건부 메서드와의 재검사

- HTTP는 캐시가 서버에게 '조건부 GET' 요청을 보낼 수 있도록 함
  - 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다를 시 객체 본문 요청
- 신선도 검사와 객체를 받아오는 것을 하나의 조건부 GET으로 결합
- 조건부 GET은 GET 요청 메시지에 특별한 조건부 헤더를 추가
  - 조건이 참인 경우 객체를 서버에서 반환
- 모든 조건부 헤더는 'If-' 접두어로 시작
  - If-Modified-Since: <\date> : 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리, Last-Modified 헤더와 사용
  - If-None-Match: <\tags> : 문서에 대한 일련번호와 같이 동작하는 특별한 태그를 제공, 태그가 다를 시 요청 처리

### 7.8.5 If-Modified-Since: 날짜 재검사

- 가장 흔하게 쓰이고 흔히 'IMS'로 불림
- 문서가 주어진 날짜 이후에 변경된 경우
  - If-Modified-Since는 참
  - GET 요청 성공
  - 새 문서가 새로운 만료 날짜 및 다른 정보들의 헤더와 함께 캐시에게 반환
- 문서가 주어진 날짜 이후에 변경되지 않은 경우
  - If-Modified-Since는 거짓
  - 서버가 304 Not Modified 응답 메시지를 클라이언트에게 반환
  - 갱신이 필요한 헤더만 보내줌
- If-Modified-Since 헤더는 응답 헤더의 Last-Modified 헤더와 함께 동작
  - 제공하는 문서에 최근 변경 일시를 붙임
- 몇몇 웹 서버는 If-Modified-Since를 실제 날짜 비교로 구현 X
  - IMS 날짜와 최근 변경일 간의 문자열 비교를 수행 (정확히 이 날짜에 마지막 변경이 일어난 것이 아니라면)

### 7.8.6 If-None-Match: 엔터티 태그 재검사

- 최근 변경 일시 재검사가 행해지기 어려운 상황
  - 일정 시간 간격으로 다시 쓰이지만 실제로 같은 데이터 일 때
  - 문서의 변경이 사소한 것일 때
  - 갖고 있는 문서의 최근 변경 일시를 파악할 수 없을 때
  - 1초보다 작은 간격으로 갱신되는 문서는 충분한 정밀도가 필요
- 문서 변경 시 엔터티 태그를 새로운 버전으로 표현 가능
  - 원 서버가 같은 태그를 갖고 있을 시 304 Not Modified
  - 다른 태그를 갖고 있을 시 새 객체를 달라고 요청
- 하나의 If-None-Match 헤더에 여러 개의 엔터티 태그 포함 가능

### 7.8.7 약한 검사기와 강한 검사기

- HTTP/1.1은 콘텐츠가 조금 변경되었더라도 같은 것이라고 서버가 주장할 수 있도록 하는 `약한 검사기` 지원
  - 'W\\' 접두사로 약한 검사기를 구분
- `강한 검사기`는 콘텐츠가 바뀔 때마다 바뀜
- 원 서버는 약한 검사기든 강한 검사기든 의미가 다를 시 태그 값을 재활용해서는 안 됨
  - 캐시가 과거의 특정 시점에서 얻은 검사기를 사용해서 검사할 수도 있음

### 7.8.8 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

- 원 서버가 반환하는 대로 클라이언트도 검사를 사용
- 두 태그 모두 사용 가능하다면 HTTP 버전에 맞게 적절한 응답
- HTTP/1.1은 태그 검사기를 보내야 하며 약한 엔터티 태그를 보낼 수 있는 이점 존재
  - Last-Modified 값을 같이 보내는 것도 선호
- 두 조건부 헤더를 서버가 모두 받을 시 두 조건부 헤더 필드의 조건에 모두 부합할 때만 304 응답 반환

## 7.9 캐시 제어

- HTTP에서 문서가 완료되기 전까지 얼마나 오랫동안 캐시 될 수 있게 할 것인지의 여러 방법들
  - Cache-Control: no-store 헤더
  - Cache-Control: no-cache 헤더
  - Cache-Control: must-revalidate 헤더
  - Cache-Control: max-age 헤더
  - Expires 날짜 헤더
  - 아무 만료 정보 없이 캐시가 스스로 휴리스틱(체험) 방법으로 결정

### 7.9.1 no-cache와 no-store 응답 헤더

- no-store
  - 캐시가 그 응답의 사본을 만드는 것을 금지
  - 캐시는 클라이언트에게 no-store 응답을 전달 뒤 객체를 삭제
- no-cache
  - 먼저 서버와 재검사 후 로컬 캐시 저장소에 저장될 수 있음
  - 재검사 없이 캐시에서 제공하지 말라는 의미
- Pragma: no-cache 헤더
  - HTTP/1.0+와의 하위호환성을 위해 HTTP/1.1에 포함
  - HTTP/1.1은 Pragma: no-cache만 이해할 수 있는 애플리케이션이 아니라면 Cache-Control: no-cache를 사용할 것

### 7.9.2 Max-Age 응답 헤더

- 신선하다고 간주했던 문서가 서버로부터 온 이후로 흐른 시간
- 초로 나타냄
- s-maxage 헤더는 max-age처럼 행동하지만 공용 캐시에만 적용
- 0으로 설정 시 캐시가 매 접근마다 문서를 캐시 하거나 리프레시 하지 않도록 요청 가능

### 7.9.3 Expires 응답 헤더

- 초 단위의 시간이 아닌 실제 만료 날짜 명시
- 몇몇 서버는 문서를 항상 만료되도록 하기 위해 Expires: 0 응답 헤더를 돌려보냄
  - 문법 위반
  - 몇몇 소프트웨어와 문제를 일으킬 수 있음

### 7.9.4 Must-Revalidate 응답 헤더

- 캐시는 성능 개선을 위해 만료된 객체를 제공하도록 설정 가능
- 해당 헤더는 캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 재검사 없이는 제공 못 함을 명시
  - 이 헤더 신선도 검사 사용 시 원 서버가 사용할 수 없는 상태라면 캐시는 504 Gateway Timeout error 반환

### 7.9.5 휴리스틱 만료

- 위의 헤더를 포함하지 않을 시 캐시는 경험적인 방법으로 최대 나이를 계산
  - 경험적인 방법을 휴리스틱이라 함
- 계산 결과 얻는 최대 나잇값이 24시간보다 클 시 Heuristic Expiration 경고
- LM 인자 알고리즘 : 유명한 휴리스틱 만료 알고리즘
  - 문서의 마지막 변경일이 예전 -> 안정적인 문서라 판단 -> 캐시에 더 오래 보관
  - 문서가 최근에 변경 -> 자주 변경되는 문서 -> 짧은 시간 동안만 캐시
- 캐시 판단 근거가 없을 시 기본 신선도 유지 기간을 설정
  - 보수적인 캐시는 0의 신선도 수명 설정
- 휴리스틱 신선도 계산은 생각보다 흔히 하게 됨

### 7.9.6 클라이언트 신선도 제약

- 웹브라우저는 브라우저나 프락시 캐시의 신선하지 않은 콘텐츠를 강제 갱신 시키는 리프레시, 리로드 버튼 소유
  - Cache-Control 요청 헤더가 추가된 GET 요청 발생 후 강제 재검사 or 콘텐츠 가져오기
- 클라이언트는 Cache-Control 요청 헤더로 제약의 강도를 설정 가능
- Cache-Control: max-stale
  - 캐시가 신선하지 않은 문자라도 자유롭게 제공
  - 느슨한 캐싱 규칙
- Cache-Control: min-fresh = <\s>
  - 클라이언트는 s초 후까지 신선한 문서만을 받아들임
- Cache-Control: no-cache, Pragma: no-cache
  - 캐시 된 리소스는 재검사하기 전에는 받아들이지 않을 것
- Cache-Control: no-store
  - 저장소에서 문서의 흔적을 최대한 빨리 삭제할 것
- Cache-Control: only-if-cached
  - 클라이언트가 캐시에 들어있는 사본만을 원함

### 7.9.7 주의할 점

- 문서 만료는 완벽한 시스템이 아님
- 퍼블리셔는 유효기간을 기게 잡지 않음

## 7.10 캐시 제어 설정

- 아파치 웹 서버가 캐시 제어를 어떻게 지원하는지?

### 7.10.1 아파치로 HTTP 헤더 제어하기

- 아파치 웹 서버는 HTTP 캐시 제어 헤더를 설정할 수 있는 메커니즘 제공
  - 대부분 활성화가 필요, 디폴트 X
  - 확장 모듈이 필요할 수도 있음
- mod_headers
  - 개별 헤더들을 설정할 수 있게 해줌
  - 지시어를 사용해 개별 HTTP 헤더 설정
  - 아파치의 정규식과 필터도 조합 가능
- mod_expires
  - 적절한 만료 날짜가 담긴 Expires 헤더를 자동으로 생성하는 프로그램 로직 제공
  - 마지막으로 접근한 날 or 수정한 날 이후의 일정 시한으로 유효기간 설정
  - 파일 종류별로 다른 만료 날짜 설정 가능
  - 편리한 기술 형식도 사용 가능
- mod_cem_meta
  - HTTP 헤더들의 파일을 특정 객체와 연결
  - 제어하고자 하는 파일에 각각 대응하는 메타파일 생성

### 7.10.2 HTTP-EQUIV를 통한 HTML 캐시 제어

- 웹 서버 설정 파일과의 상호작용 없이도 쉽게 HTML 문서에 HTTP 헤더 정보를 부여할 수 있도록 하기 위해 정의
- HTTP 2.0에서 정의
- HTML의 문서 최상단에 위치 & 연동되어야 하는 HTTP 헤더들을 정의
- HTTP 서버는 문서를 처리하는 과정에서 이 정보를 사용
- 이 기능을 지원하는 웹 서버나 프락시는 거의 없음
  - 서버의 부하 가중 & 설정값이 정적 & HTML을 제외한 다른 타입 지원 X
- 이를 지원하는 HTML 브라우저들은 중간의 프락시 캐시와는 다른 캐시 제어 규칙 적용
  - 이는 캐시 만료에 대한 동작에 혼란 초래

## 7.11 자세한 알고리즘

- HTTP 명세는 문서의 나이와 캐시 신선도를 계산하는 알고리즘 제공

### 7.11.1 나이와 신선도 수명

- 캐시는 신선도를 계산하기 위해 두 가지 값을 계산
  - 캐시 된 사본의 나의 & 신선도 수명
  - 나이가 신선도 수명보다 작아야 신선
- 문서의 나이는 서버가 문서를 보낸 후 그 문서가 나이를 먹은 시간의 총합
  - Age 헤더나 서버가 생성한 Date 헤더를 통해 판별
- 캐시는 서버 만료 정보와 클라이언트 신선도 요구사항을 조합해서 수명도 판별

### 7.11.2 나이 계산

- 응답의 나이 : 응답이 서버에서 생성되었을 때부터 지금까지의 총 시간
  - 라우터들과 게이트웨이를 떠돌아다닌 시간도 포함
- 응답의 전체 나이 : Date나 Age 헤더를 분석한 값 + 로컬 캐시에 얼마나 머물렀는지
- 겉보기 나이는 Date 헤더에 기반한다.
  - 가장 단순한 기초적 나이 계산
  - 응답을 받은 시각 - Date 헤더 값
  - 모든 컴퓨터의 시계가 잘 동기화되진 않으므로 다를 수 있음
  - 클록 스큐 : 두 컴퓨터의 시계 설정 차이로 인한 문제
  - 클록 스큐로 인해 나이가 음수일 시 그것을 0으로 만들어야 함
  - 프락시와 캐시는 Date 헤더를 변경해서는 안 됨
- 점층적 나이 계산
  - HTTP/1.1에선 동기화된 시계가 없는 문제를 위해 프락시나 캐시가 통과할 때마다 Age 헤더에 상대적인 나이를 누적해서 더하도록 함
  - Age 헤더 값은 프락시를 통과하며 점점 늘어남
  - 비 HTTP/1.1 장치는 Age 헤더 인식 X
  - 보정된 겉보기 나이는 Date 기반과 Age 기반의 값 중 높은 값
- 네트워크 지연에 대한 보상
  - 문서가 네트워크나 교통 혼잡에 긴 시간 동안 갇혀있었던 경우 추정에 영향을 미침
  - HTTP/1.1은 응답을 받은 시각에 요청을 보낸 시간을 빼서 응답 지연 추정 값을 구하고 보정된 겉보기 나이에 더함

### 7.11.3 완전한 나이 계산 알고리즘

- 문서에 대한 요청이 캐시에 도착했을 때 그 문서가 캐시에 얼마나 오랫동안 머물렀는지 알아야 함
- 나이는 문서가 캐시에 도착했을 때의 나이에 사본이 얼마나 오래 캐시에 있었는지를 더한 값

### 7.11.4 신선도 수명 계산

- 신선도 수명은 문서가 얼마나 오랜 시간 동안 클라이언트에게 전달할 수 있는 게 허용되는지 말해줌
- 서버와 클라이언트 제약조건에 의존
  - 서버가 문서에 대한 정보를 갖고 있을 수도 있음
  - 클라이언트가 다른 가이드라인을 갖고 있을 수도 있음

## 7.12 캐시와 광고

- 캐시는 사용자들에게 좋은 경험, 사업자들에게 트래픽을 줄일 수 있도록 해줌

### 7.12.1 광고 회사의 딜레마

- 캐시는 원 서버가 실제 접근 횟수를 알 수 없게 숨길 수 있음
- 캐시가 완벽하게 동작할 시 원 서버는 HTTP 접근을 전혀 수신하지 않게 됨

### 7.12.2 퍼블리셔의 응답

- 광고 회사들은 광고 시청 수를 가로채지 못하도록 '캐시 무력화' 기법 사용
  - 광고를 CGI 게이트웨이를 통해 제공
  - 매 접근마다 광고 URL을 고쳐 씀
- 이상적으론 캐시가 트래픽을 흡수하고 캐시 적중이 얼마나 많이 일어났는지 알려줘야 함
  - 모든 접근에 대해 원 서버와 재 검사하도록 캐시를 설정하는 방법
  - 물론 트랜잭션이 느려지고 본문 데이터는 전송 X

### 7.12.3 로그 마이그레이션

- 이상적인 해결 책 하나 : 서버로 적중 로그를 전달
- 적중 로그는 크기 때문에 옮기기 어려움
- 표준화, 조직화가 X, 인증 및 프라이버시 이슈 존재
- 효과를 보기 위해선 공동 사업 협력이 필요

### 7.12.4 적중 측정과 사용량 제한

- Meter 헤더
  - HTTP에 때때로 특정 URL에 대한 캐시 적중 횟수를 정기적으로 서버에게 돌려주는 헤더
- 사용량 제한
  - 서버는 캐시가 서버에게 보고해야 하기 전 문서를 제공 가능 횟수, 소모할 수 있는 처리시간을 제어
  - 캐시 된 리소스가 얼마나 많이 사용될 수 있는지 서버가 제어할 수 있게 해줌
