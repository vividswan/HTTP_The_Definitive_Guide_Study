# 16장 - 국제화

- HTTP는 여러 문자로 된 국제 문서들의 처리 및 전송을 지원해야 함

## 16.1 국제적인 콘텐츠를 다루기 위해 필요한 HTTP 지원

- 엔터티 본문은 비트
  - 서버가 클라이언트에게 각 문서의 문자와 언어를 알려줘서 클라이언트가 비트들을 문자로 풀어내고 처리
  - 서버는 HTTP Content-Type charset 매개변수, Content-Language 헤더를 통해 알려줌
  - 클라이언트는 Accept-Charset, Accept-Language 헤더를 보내 이해할 수 있는 언어와 알파벳 알고리즘 전달 (q로 품질 인자도 전달 가능)

## 16.2 문자집합과 HTTP

- 국제 알파벳 스크립트와 문자집합 인코딩은 웹 국제화에서 가장 중요하면서 헷갈림

### 16.2.1 차셋(Charset)은 글자를 비트로 변환하는 인코딩이다

- Charset 값
  - 어떻게 엔터티 콘텐츠 비트들을 특정 문자 체계의 글자들로 바꾸는지 말해줌
  - Charset 태그가 비트들을 글자들로 변환하거나 그 반대의 일을 해주는 알고리즘을 명명
  - MIME 문자집합에 표준화되어 있고 IANA과 관리
- 몇몇 문자 인코딩은 글자 당 비트 수가 일정하지 않아 복잡한 가변 길이 코드

### 16.2.2 문자집합과 인코딩은 어떻게 동작하는가

- 비트들을 문자로 변환하는 과정
  - 인코딩 구조를 사용하여 디코딩 -> 특정 문자로 식별될 수 있는 문자 코드로 변환
  - 코딩된 문자집합을 사용하여 글자를 찾음 -> 특정 요소를 선택
- 국제화된 문서 시스템의 핵심 목표는 표현에서 의미를 분리해 내는 것
  - 글자 모양 등은 디스플레이 소프트웨어가 결정

### 16.2.3 잘못된 차셋은 잘못된 글자들을 낳는다

- 클라이언트가 잘못된 charset 매개변수를 사용한다면 클라이언트는 이상한 깨진 글자를 보여줄 것

### 16.2.4 표준화된 MIME 차셋 값

- 특정 문자 인코딩과 특정 코딩된 문자집합의 결합을 MIME 차셋이라고 부름
  - HTTP는 표준화된 MIME 차셋 태그를 Content-Type과 Accept-Charset 헤더에 사용
  - IANA에 등록되어 있음

### 16.2.5 Content-Type charset 헤더와 META 태그

- Content-Type 헤더에 charset 매개변수와 함께 MIME 차셋 태그를 보냄
- 문자집합이 명시적으로 나열되지 않았다면 수신자는 문서의 콘텐츠로부터 추측 시도
  - 실제 텍스트를 스캐닝 하여 문자 인코딩 추측
- HTTP 문서에선 "\<META HTTP-EQUIV="Content-Type">" 태그에서 찾을 수 있음

### 16.2.6 Accept-Charset 헤더

- 대부분의 클라이언트는 모든 종류의 문자 코딩과 매핑 시스템을 지원 X
- 서버에게 정확히 어떤 문자 체계를 지원하는지 Accept-Charset 요청 헤더를 통해 알려줌
  - 클라이언트가 지원하는 문자 인코딩의 목록
- Accept-Charset 요청 헤더에 대응하는 Content-Charset 응답 헤더는 존재 X

## 16.3 다중언어 문자 인코딩에 대한 지침

- 국제화 애플리케이션과 콘텐츠로 많은 작업을 하는 HTTP 프로그래머는 문자집합 체계에 대해 깊이 이해할 필요가 있음

### 16.3.1 문자집합 용어

- 문자
  - 글쓰기의 최소 단위
  - 알파벳 글자, 숫자, 구두점, 기호 등
  - 표준화된 이름 집합이 개발되어 있음
- 글리프(glyph)
  - 하나의 글자를 표현하기 위한 획의 패턴이나 다른 것과 구분되는 유일한 시각적 형태
  - 하나의 글자를 여러 방식으로 쓰는 것이 가능하다면 글리프를 여러 개 가질 수 있음
- 코딩된 문자(coded character)
  - 글자를 다룰 수 있도록 각 글자에 할당된 유일한 숫자
- 코드 공간(coding space)
  - 문자 코드 값으로 사용하려고 계획해 둔 정수의 범위
- 코드 너비(code width)
  - 각 문자 코드의 (고정된 크기의) 비트 개수
- 사용 가능 문자집합(character repertoire)
  - 글자들에 대한 특정한 작업 집합
- 코딩된 문자 집합(coded character set)
  - 사용 가능 문자집합을 받아서 각 글자에 코드 공간의 코드를 할당해 주는 코딩된 문자들의 집합
  - 실제 글자들에 숫자로 된 문자 코드를 대응시킨 것
- 문자 인코딩 구조
  - 숫자로 된 문자 코드들을 콘텐츠 비트의 연속으로 인코딩하는 알고리즘
  - 원래대로 디코딩도 하는 알고리즘
  - 압축, 전송 상의 제약 회피, 중복된 코딩된 문자집합들을 통합하는 목적

### 16.3.2 '차셋(Charset)'은 형편없는 이름이다

- MIME 차셋 태그는 문자집합을 의미하는 것이 결코 아님
  - MIME 차셋 값은 데이터 비트를 고유한 문자의 코드로 매핑하는 알고리즘의 이름
  - 문자 인코딩 구조 + 코딩된 문자집합의 개념

### 16.3.3 문자

- 쓰기의 기본적인 구성요소
- 글꼴이나 스타일에 독립적
- 같은 글자라도 그 글자가 단어에서 어디에 위치하느냐에 따라 각각 다른 모양을 갖는 표기 체계도 많음

### 16.3.4 글리프(glyphs), 연자(ligatures) 그리고 표현 형태

- 문자는 유일하고 추상화된 언어의 요소
- 글리프는 각 글자를 그리는 특정한 방법
  - 글리프 하나를 다른 것으로 바꾸었을 때 텍스트의 의미가 바뀐다면 그 두 글리프들은 서로 다른 글자
- 문자와 그것의 표현 형태를 혼동하지 말 것
  - 쓰기를 멋지게 보이도록 하는 연자

### 16.3.5 코딩된 문자집합(Coded Character Set)

- 코딩된 문자집합은 숫자로 된 코드를 글자에 대응시키는 배열이라고 생각할 수 있음
- US-ASCII: 모든 문자집합의 어머니
  - 아스키는 가장 유명한 코딩된 문자 집합
  - 값 0-127만 사용 -> 7비트만이 필요
- iso-8859
  - 하이비트를 이용해서 추가한, US-ASCII의 8비트 확대 집합들
  - 지역에 따라 커스터마이징된 문자집합 제공
  - iso-8859-1은 HTM을 위한 기본 문자집합 (대부분의 유럽어 텍스트를 표현)
- JIS X 0201
  - 아스키를 일본어 가타카나 반각 문자를 더해 확장한 문자집합
- JIS X 0208과 JIS X 0212
  - JIS X 0201로는 실질적인 표현에 한계가 있기에 더 많은 코딩된 문자를 정의
  - JIS X 0208 : 최초의 멀티 바이트 일본어 문자집합
- UCS
  - 전 세계의 모든 글자를 하나의 코딩된 문자 집합으로 통합하려 노력하는 세계적인 표준
  - 유니코드는 UCS 표준을 따르는 상업적인 콘소시엄

### 16.3.6 문자 인코딩 구조

- 숫자로 된 문자 코드를 콘텐츠 비트들로 변환하고 다른 쪽에서는 그들을 다시 코드로 환원
  - character code를 비트들로 인코딩하고 다시 원래대로 돌려놓음
- 종류
  - 고정폭 : 각 코딩된 문자를 고정된 길이의 비트로 표현 (빠르게 처리될 수 있지만 공간 낭비 가능성)
  - 가변폭(비모달) : 다른 문자 코드 번호에 다른 길이의 비트 사용(자주 사용하는 비트 길이는 줄이고 호환성 유지)
  - 가변폭(모달) : 다른 모드로의 전환을 위해 특별한 'escape' 패턴 사용, 복잡한 표기 체계를 효과적으로 지원

#### 몇 가지 인코딩 구조

- 8비트
  - 8비트 고정폭 아이덴티티 인코딩
  - 256개 문자의 코드 범위에 대한 문자집합 지원
  - iso-8859
- UTF-8
  - 인기 있는 UCS를 위해 설계된 문자 인코딩 구조
  - 문자 코드의 값을 위해 비모달 가변길이 인코딩 사용
  - 첫 바이트의 선두 비트들은 인코딩된 문자의 길이를 바이트 단위로 나타냄, 그 이후의 바이트들은 각각 6비트의 코드 값을 담음
  - 첫 번째 인코딩된 바이트의 하이 비트가 0이면 길이는 단 1바이트고 남은 7비트가 문자코드를 담음 -> 아스키와의 호환성 확보
- iso-2022-jp
  - 일본어 인터넷 문서를 위해 널리 사용되는 인코딩
  - 128보다 작은 값으로만 이루어진 가변길이 모달 인코딩
  - 인코딩 콘텍스트는 언제나 네 가지 미리 정의된 문자집합 중 하나로 설정
- ecu-jp
  - ecu : 'Extended Unix Code'
  - 또 하나의 인기 있는 일본어 인코딩
  - 여러 표준 일본어 문자집합을 사용할 수 있도록 해주는 가변길이 인코딩
  - 모드 간의 전환을 위한 이스케이프 문자열은 존재 X
- ecu-kr
  - 한글 인터넷 문서를 위해 널리 사용되는 가변길이 인코딩
  - KS X 1003, KS X 1001 두 가지 문자 집합을 지원
  - 한국어에서 사용되는 한글을 모두 표현하기 위해 한글 채움 문자를 이용해 한글을 표현

## 16.4 언어 태그와 HTTP

- 언어 태그는 언어에 이름을 붙이기 위한 짧고 표준화된 문자열
- 영어(en), 독일어(de), 한국어(ko) 등 많은 언어에 대한 언어 태그가 존재
- 지역에 따라 변형된 언어나 방언도 표현 가능

### 16.4.1 Content-Language 헤더

- 엔터티가 어떤 사용자를 대상으로 하고 있는지 서술
- 텍스트 문서 외에 다른 종류의 미디어들도 이 헤더를 가질 수 있음
- 여러 언어를 나열할 수도 있음

### 16.4.2 Accept-Language 헤더

- 클라이언트는 자신이 이해할 수 있는 콘텐츠를 요청하기 위해 Accept-Language와 Accept-Charset을 사용할 수 있음

### 16.4.3 언어 태그의 종류

- 일반적인 언어의 종류
- 특정 국가의 언어
- 방언
- 지방어
- 그 외의, 다른 언어의 변형이 아닌 표준 언어
- 비표준 언어

### 16.4.4 서브태그

- 언어 태그는 하이픈으로 분리된 하나 이상의 서브태그로 이루어져 있음
  - 첫 번째 서브태그는 주 서브태그
  - 두 번째 서브태그는 선택적, 자신만의 이름 표준을 따름
  - 세 번째부터의 서브 태그는 등록되어 있지 않다.

### 16.4.5 대소문자의 구분 및 표현

- 모든 태그는 대소문자 구분 X
- 관용적으로 언어를 나타낼 땐 소문자, 국가를 나타낼 땐 대문자

### 16.4.6 IANA 언어 태그 등록

- IANA는 표준 언어 태그의 목록을 관리

### 16.4.7 첫 번째 서브태그: 이름공간

- 첫 번째 서브태그는 표준화된 언어 토큰
- 규칙
  - 두 글자라면 ISO 639와 639-1 표준의 언어 코드
  - 세 글자라면 ISO 639-2 표준과 확장에 열거된 언어 코드
  - 글자 'i'라면 이 언어 태그는 틀림없이 IANA에 등록된 것
  - 글자 'x'라면 이 언어 태그는 특정 개인이나 집단 전용의 비표준 확장 서브태그

### 16.4.8 두 번째 서브태그: 이름공간

- ISO 3166 국가 코드와 지역 표준 집합에서 선택된 표준화된 국가 토큰
- 규칙
  - 두 글자라면 ISO 3166에 정의된 국가/지역
  - 3~8 글자라면 IANA에 등록된 것
  - 한 글자라면 잘못된 것

### 16.4.9 나머지 서브태그: 이름공간

- 세 번째 & 그 이후의 서브태그는 8자 이하의 알파벳과 숫자로 이루어져야 함

### 16.4.10 선호 언어 설정하기

- 웹브라우저 프로필에서 선호 언어 설정 가능

## 16.5 국제화된 URI

- URI는 국제화를 그다지 지원 X
  - US-ASCII의 부분집합으로 구성

### 16.5.1 국제적 가독성 vs 의미 있는 문자들

- 전 세계의 모두가 공유하기는 바램과 URI가 사용하기 쉽고 기억하기 쉽길 바라는 바램이 충돌
  - 쉬운 조작과 공유를 위해 제한된 공통 문자집합을 선택
  - 비영어권 사람들은 쉽게 사용할 수 없음

### 16.5.2 URI에서 사용될 수 있는 문자들

- URI에서 사용할 수 있는 US-ASCII 문자들의 부분집합
  - 예약된 문자들
  - 예약되지 않은 문자들
  - 이스케이프 문자들
- 예약되지 않은 문자들은 일반적으로 사용될 수 있음
- 예약된 문자들은 일반적으로 사용 X

### 16.5.3 이스케이핑과 역이스케이핑(unescaping)

- URI 이스케이프는 예약된 문자나 다른 지원하지 않는 글자들을 안전하게 URI에 삽입할 수 있는 방법 제공
- 이스케이프는 퍼센트 글자(%) 하나와 뒤이은 16진수 글자 둘로 이루어진 세 글자 문자열
  - 16진수 두 글자는 US-ASCII 문자의 코드를 나타냄
  - 이스케이핑된 코드 바이트들은 원래의 ASCII 코드 바이트로 변환 (언이스케이핑)
- URI를 데이터가 필요할 때만 언이스케이핑 해야 함
- 어떤 URI도 결코 두 번 언이스케이핑 되지 않도록 해야 함
  - 데이터 손실 유발 가능

### 16.5.4 국제 문자들을 이스케이핑하기

- 이스케이프 값들은 US-ASCII 코드의 범위(0-127)에 있어야 함
  - 확장 문자들을 표현하기 위해 이스케이프 값을 사용하는 것은 오용

### 16.5.5 URI에서의 모달 전환

- 몇몇 URI는 다른 문자집합의 글자를 표현하기 위해 ASCII 문자열 사용 (모달과 함께)
- URI는 그다지 국제화에 친화적 X
- 언어 유연성의 목표보다 이식성이 더 중요

## 16.6 기타 고려 사항

### 16.6.1 헤더와 명세에 맞지 않는 데이터

- HTTP 헤더는 반드시 US-ASCII 문자집합의 글자들로만 이루어져야 함
  - 글자들을 처리하는 운영체제와 라이브러리 루틴들이 ASCII 범위를 벗어난 글자 지원 X
  - ASCII가 아닌 글자가 주어졌을 때 충돌을 일으킬 확률 높음

### 16.6.2 날짜

- HTTP 애플리케이션은 명세에 맞지 않는 날짜를 관대하게 받아들이고 충돌을 일으키지 말아야 함
- 파싱 할 수 없는 날짜를 받았을 시 서버는 그것을 보수적으로 다루어야 함

### 16.6.3 도메인 이름

- 국제화 도메인 이름
  - 국제화 문자를 포함하는 도메인
- 퓨니코드를 이용해 대부분의 웹브라우저들이 지원
  - 유니코드 문자열을 호스트 명에서 사용 가능한 문자열로 변환
  - 이 기법으로 웹브라우저들은 다국어로 된 도메인 이름을 알파벳과 숫자 등으로 변환
