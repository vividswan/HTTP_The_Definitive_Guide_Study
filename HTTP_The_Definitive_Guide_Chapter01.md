# 1장 - HTTP 개관

- HTTP는 현대 인터넷의 공용어
- 1장에선 HTTP를 간결하게 설명

## 1.1 HTTP: 인터넷의 멀티미디어 배달부

- HTTP는 전 세계의 정보를 웹브라우저로 빠르고, 간편하고, 정확하게 옮겨줌
- HTTP는 신뢰성 있는 데이터 전송 프로토콜
  - 전송 중 손상, 꼬임 X

## 1.2 웹 클라이언트와 서버

- 웹 콘텐츠는 웹 서버에 존재 (HTTP 서버라고 불림)
  - 인터넷의 데이터를 저장 & 클라이언트가 요청한 데이터를 제공
- 가장 흔한 HTTP 클라이언트는 웹브라우저
- "http://www.oreilly.com/index.html"과 같은 페이지를 열어보는 과정
  - 웹브라우저는 HTTP 요청을 "www.oreilly.com" 서버로 전송
  - 서버는 요청받은 객체("/index.html")를 찾고 성공하면 그것의 정보와 함께 HTTP 응답에 실어 클라이언트에게 전송

## 1.3 리소스

- 웹 서버는 웹 리소스를 관리하고 제공
- 웹 리소스는 웹 콘텐츠의 원천
  - 텍스트 파일, HTML 파일, 마이크로소프트 워드 파일과 같은 정적인 파일
  - 사용자가 누구인지, 어떤 정보를 요청했는지 등에 따라 동적인 콘텐츠도 제공 가능
  - 어떤 종류의 콘텐츠 소스도 리소스가 될 수 있음

### 1.3.1 미디어 타입

- HTTP는 웹에서 전송되는 객체 각각에 신중하게 MIME 타입이라는 데이터 포맷 라벨을 붙임
  - `MIME(Multipurpose Internet Mail Extensions, 다목적 인터넷 메일 확장)`
  - 원래 이메일에서만 사용 -> HTTP에서도 채택
- 웹 서버는 모든 HTTP 객체 데이터에 MIME 타입을 붙임
- MIME 타입은 사선(/)으로 구분된 주 타입과 부 타입으로 이루어진 문자열 라벨
  - ex) text/html, text/plain, image/jpeg, image/gif ...
  - 수백 가지의 잘 알려진 MIME 타입 & 그보다 더 많은 실험용, 특정 용도의 MIME 타입 존재

### 1.3.2 URI

- 클라이언트는 관심 있는 리소스를 각자 이름으로 지목할 수 있다.
- `URI(uniform resource identifier)`,`통합 자원 식별자`로 불림
- 정보 리소스를 고유하게 식별하고 위치 지정 가능 (우편물 주소처럼..)

### 1.3.3 URL

- `통합 자원 지시자(uniform resource locator, URL)`는 리소스 지시자의 가장 흔한 형태
  - 특정 서버의 한 리소스에 대한 구체적인 위치 서술
- 대부분 URL은 세 부분으로 이루어진 표준 포맷을 따름
  - 첫 번째 부분은 스킴(scheme) : 리소스에 접근하기 위해 사용되는 프로토콜
  - 두 번째 부분은 서버의 인터넷 주소
  - 마지막은 웹 서버의 리소스
- 오늘날 대부분의 URI는 URL

### 1.3.4 URN

- `유니폼 리소스 이름(uniform resource name, URN)`
  - 한 리소스에 대해 그 리소스의 위치에 영향 받지않는 유일무이한 이름 역할
  - 위치 독립적
- URN은 실험 중인 상태 & 널리 채택되지 않음
  - 효율적인 동작을 위해 URN은 리소스 위치를 분석하기 위한 인프라 지원이 필요 (인프라가 부재)
  - 전망은 밝음

## 1.4 트랜잭션

- HTTP 트랜잭션은 요청 명령(클라이언트에서 서버)과 응답 결과(서버에서 클라이언트)로 구성
  - HTTP 메시지라고 불리는 정형화된 데이터 덩어리를 이용해 상호작용이 구성

### 1.4.1 메서드

- 모든 HTTP 요청 메시지는 한 개의 메서드를 가짐
- 메서드는 서버에게 어떤 동작이 취해져야 하는지 말해줌
- 흔히 쓰이는 HTTP 메서드 다섯 가지
  - GET : 서버에서 클라이언트로 지정한 리소스를 보낼 것
  - PUT : 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장
  - DELETE : 지정한 리소스를 서버에서 삭제
  - POST : 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보낼 것
  - HEAD : 지정한 리소스에 대한 응답에서, HTTP 헤더 부분만 보낼 것

### 1.4.2 상태 코드

- 모든 HTTP 응답 메시지는 상태 코드와 함께 반환
  - 상태 코드는 클라이언트에게 요청이 성공했는지, 혹은 추가 조치가 필요한지 알려주는 세 자리 숫자
- 흔히 쓰이는 상태 코드
  - 200 : 좋음, 문서가 바르게 반환되었음
  - 302 : 다시 보낼 것, 다른 곳에 가서 리소스를 가져갈 것
  - 404 : 없음, 리소스를 찾을 수 없음
- 텍스트로 된 "사유 구절"도 함께 보냄
  - 이 구문은 단지 설명만을 위해서 포함된 것, 실제 응답 처리는 숫자로 된 코드 사용
  - 사유 구절이 달라도 상태 코드가 같다면 모두 같은 것으로 취급

### 1.4.3 웹페이지는 여러 객체로 이루어질 수 있다

- 애플리케이션에선 보통 하나의 작업을 수행하기 위해 여러 HTTP 트랜잭션을 수행
  - 웹페이지는 보통 하나의 리소스가 아닌 리소스의 모음

## 1.5 메시지

- HTTP 메시지는 단순한 줄 단위의 문자열
  - 이진 형식이 아닌 일반 텍스트
- 요청 메시지 : 웹 클라이언트에서 웹 서버로 보낸 HTTP 메시지
- 응답 메시지 : 서버에서 클라이언트로 가는 메시지
- HTTP 메시지는 다음의 세 부분으로 이루어짐
  - 시작줄 : 메시지의 첫 줄, 요청이라면 무엇을 해야 하는지 & 응답이라면 무슨 일이 일어났는지
  - 헤더 : 0개 이상의 헤더 필드가 시작줄 다음으로 이어짐, 쌍점(:)을 기준으로 하나의 이름과 하나의 값으로 구성, 빈 줄로 끝남
  - 본문 : 어떤 데이터든 들어갈 수 있는 메시지 본문, 임이의 이진 데이터도 포함 가능

### 1.5.1 간단한 메시지의 예

- 웹브라우저에서 리소스 "http://www.joes-hardware.com/tools.html"을 요청
- 웹브라우저는 HTTP 요청 메시지를 보냄
  - 시작 줄에 GET 메서드와 로컬 리소스(/tools.html), HTTP 1.0 프로토콜 버전 명시, 본문은 X
- 서버는 HTTP 응답 메시지를 돌려줌
  - HTTP 버전 번호(HTTP/1.0), 성공 상태 코드(200), 사유 구절(OK), 응답 헤드 필드 영역, 요청한 문서가 담겨있는 응답 본문 구성

## 1.6 TCP 커넥션

- `TCP(Transmission Control Protocol, 전송 제어 프로토콜)`
- HTTP 메시지는 TCP 커넥션을 통해 한 곳에서 다른 곳으로 옮겨짐

### 1.6.1 TCP/IP

- HTTP는 애플리케이션 계층 프로토콜
  - 네트워크 통신의 핵심적인 세부사항에 대해서 신경 X
  - 대중적이고 신뢰성 있는 TCP/IP 프로토콜에게 맡김
- TCP는 다음을 제공
  - 오류 없는 데이터 전송
  - 순서에 맞는 전달
  - 조각나지 않는 데이터 스트림
- TCP/IP는 TCP와 IP가 층을 이루는 패킷 교환 네트워크 프로토콜의 집합
- HTTP는 TCP 위의 계층, TCP는 IP 위의 계층

### 1.6.2 접속, IP 주소 그리고 포트 번호

- 서버 사이에 TCP/IP 커넥션을 맺어야 메시지 전송 가능
  - URL 을 이용해 서버의 IP 주소와 포트 번호를 알아낼 수 있음
- 호스트 명은 IP 주소에 대한 이해하기 쉬운 형태의 별명
  - DNS라 불리는 장치를 통해 IP로 변환
- 포트 번호가 없는 URL의 경우 기본값 80이라고 가정하면 됨
- 연결 순서
  1. 서버의 URL에서 호스트 명 추출
  2. 호스트 명을 IP로 변환
  3. 포트 번호가 있다면 추출
  4. TCP 커넥션
  5. HTTP 요청을 보냄
  6. HTTP 응답을 받음
  7. 커넥션이 닫히면, 웹브라우저는 문서를 보여줌

### 1.6.3 텔넷(Telnet)을 이용한 실제 예제

- 키보드를 텔넷 유틸리티는 목적지의 TCP 포트로 연결해 주고 출력 TCP 포트를 화면으로 연결
  1. IP 주소를 찾아 그 컴퓨터의 80번 포트로 TCP 커넥션을 맺어줌
  2. 커넥션이 연결된 후 HTTP 요청을 타이핑해서 입력
  3. 요청이 완료되면 서버는 콘텐츠를 HTTP 응답에 담아 반환하고 커넥션을 끊음
- 텔넷은 HTTP 클라이언트를 잘 흉내 내지만 서버로서는 변변치 않음

## 1.7 프로토콜 버전

- HTTP/0.9
  - 1991년에 나온 HTTP 프로토타입
  - 디자인 결함 & 구식 클라이언트하고만 사용 가능
  - GET 메서드만 지원
  - MIME 타입, HTTP 헤더, 버전 번호는 지원 X
- HTTP/1.0
  - 처음으로 널리 쓰이기 시작한 HTTP 버전
  - 버전 번호, HTTP 헤더, 추가 메서드, 멀티미디어 객체 처리를 추가
- HTTP/1.0+
  - 1900년대 중반
  - "keep-alive" 커넥션, 가상 호스팅 지원, 프락시 연결
- HTTP/1.1
  - HTTP 설계의 구조적 결함 교정, 두드러진 성능 최적화, 잘못된 기능 제거에 집중
  - 더 복잡해진 웹 애플리케이션과 배포를 지원
  - 현재의 HTTP 버전
- HTTP/2.0
  - HTTP/1.1 성능 문제를 개선하기 위해 구글의 SPDY 프로토콜을 기반으로 설계가 진행 중인 프로토콜

## 1.8 웹의 구성요소

- 프락시 : 클라이언트와 서버 사이에 위치한 HTTP 중개자
- 캐시 : 많이 찾는 웹페이지를 클라이언트에 가까이 보관하는 HTTP 창고
- 게이트웨이 : 다른 애플리케이션과 연결된 특별한 웹 서버
- 터널 : 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시
- 에이전트 : 자동화된 HTTP 요청을 만드는 준 지능적 웹 클라이언트

### 1.8.1 프락시

- 클라이언트와 서버 사이에 위치, 클라이언트의 모든 HTTP 요청을 받아 서버에 전달
- 주로 보안을 위해 사용 (신뢰할 만한 중개자 역할)
- 요청과 응답을 필터링

### 1.8.2 캐시

- 자신을 거쳐 가는 문서들 중 자주 찾는 것의 사본을 저장해두는 HTTP 프락시 서버
- 클라이언트는 서버 보다 캐시에서 훨씬 더 빨리 문서를 다운로드할 수 있음
- HTTP는 캐시를 효율적으로 동작하게 하고 캐시 된 콘텐츠를 최신 버전으로 유지하면서 프라이버시도 보호하기 위한 많은 기능을 정의

### 1.8.3 게이트웨이

- 게이트웨이는 다른 서버들의 중개자로 동작하는 특별한 서버
  - 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용
  - 클라이언트는 자신이 게이트웨이와 통신하고 있음을 알아채지 못함
- 예시로, HTTP/FTP 게이트웨이는 FTP URI에 대한 HTTP 요청을 받아들인 뒤 FTP 프로토콜을 통해 문서를 가져옴

### 1.8.4 터널

- 터널은 두 커넥션 사이에서 날 데이터를 열어보지 않고 그대로 전달해 주는 HTTP 애플리케이션
- 대표적인 예로 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송함으로써 웹 트래픽만 허용하는 사내 방화벽

### 1.8.5 에이전트

- 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램
  - 웹 요청을 만드는 애플리케이션은 뭐든 HTTP 에이전트
